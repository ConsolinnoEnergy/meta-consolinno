From: "Enrico Scholz" <enrico.scholz@sigma-chemnitz.de>
Subject: 0000-generic
Date: Thu, 21 Sep 2023 15:02:46 +0200
X-Committed: Thu, 21 Sep 2023 15:02:46 +0200

Patchset containing changes from:

 5850686e12c9 ConegxDriver: update to v1.1.5
 36e8b470d240 ConegxDriver: update to v1.1.4
 e5036e2f3a9d Conegx Driver: update to v1.1.3
 5d993a5e7958 decrease dmesg output
 f57ce6bc576a prepare register buffer
 8d3c06c27e0c Conegx Driver update to v1.1.2
 846e15e7ea6e update Conegx Driver to v1.1.1
 0b8e8795fa96 Conegx Driver: Set OS Ready after MSP Reset
 d8a901e826f1 Conegx Driver: adjust RST PIN, change pr_debug to pr_info
 b58609e48b55 update Conegx Driver to v1.1.0
 a2f0abe607bd update conegx to 1.0.0
 7aa7deb517dc reactivate tpm on /dev/tpm0
 22aa29d90ac1 Add defconfig for i.MX6ull consolinno base module
 284bf4ecbb26 BACKPORT: ARM: dts: imx6: phytec: Add eeprom pagesize
 af186b2f04c4 BACKPORT: ARM: dts: imx6: phytec: Set correct eeprom compatible
 8a212ccccbb2 i2c: imx: Fix typo introduced by merge
 a2f3a2264ce5 ARM: dts: imx6ul/imx6ull: phycore: Increase SOC voltage domain
 b900e23bf638 ARM: dts: imx6ul: segin: Set status of backlight regulator to disabled
 ac0921949ea6 net: fec: Use alias for device number
 d87b581df72e ARM: configs: Add wifi support as loadable module
 0e41872ece8f ARM: mach-imx: Add ocotp compatible for imx6ull
 2949c15c1861 ARM: configs: Remove da9063 configs from platform config
 2fa5cf8d64c9 ARM: dts: imx6ul: segin: Disalbe over current polarity
 de50c0c0b650 NXP: MLK-11476 iio: adc: Enable i.MX6SX adc driver.
 2e35a28f227d BACKPORT: ARM: dts: imx: use generic name bus
 7c767b7e8586 FROMLIST: Input: stmpe: Add axis inversion and swapping capability
 51941889caf0 ARM: dts: imx6ul: segin: Add spidev node to phyboard-segin
 2a4a754e64e4 ARM: dts: imx6ul: segin: Use DMA for data transfer with spi
 e60bba89d5c9 ARM: mach-imx: Set system_serial from ocotp registers
 a34995226e4c ARM: imx6ul: Print SOC revision on boot and set system_rev
 5dffc6790b0a ARM: dts: imx6ul: phycore: Add dc regulator as cpu supply
 bf4fd2b7d8d1 cpufreq: Add dc regulator support in the cpufreq driver
 d4984b3e4f30 IPDUBSP-88 gpmi-nand: Add ERR007117 protection for nfc_apply_timings
 da452b4ac77b IPDUBSP-88 gpmi-nand: enable all gpmi clocks before disabling
 f76082fcf211 IPDUBSP-88 gpmi-nand: Disable all gpmi clocks before switching clock rate
 7ea96990af6e IPDUBSP-85 ARM: imx6ul: phy_fixup consider led-mode
 7dad19058d51 ARM: dts: imx6ul: phycore-segin: Correct node name for stmpe touch-controller
 0106fb74c6b5 ARM: dts: imx6ul: phyboard-segin: Port expansion boards from v4.14.184-phy
 b6bf6eb4fa98 ARM: dts: imx6ul: phyBOARD-Segin Add RS485 variant
 3aa74c9ba8a4 ARM: dts: imx6ul: segin: Add phyBOARD-Segin with eMMC phyCORE-i.MX6UL
 c5cdcd8ae00f BSPYOCTOIMX6-1030 FROMLIST: HACK: nvmem: core: don't consider subnodes not matching binding
 1b077694db42 Revert "BSPYOCTOIMX6-1030 nvmem: core: Fix nvmem binding compatibility problem"
 9320071d1011 BSPYOCTOIMX6-1053 ARM: dts: imx6: phyboard-mira: Port expansion boards from v4.19.100-phy
 859ca0a621d4 BSPYOCTOIMX6-1053 ARM: dts: imx6qdl: Add Support for PHYTEC phyBOARD-Mira variants
 3fdd0823021c BSPYOCTOIMX6-1053 ARM: dts: phyboard: Port dts-files from v4.19.100-phy
 3aab84ca3d77 BSPYOCTOIMX6-1158 media: mt9p031: Fix corrupted frame after restarting stream
 7f102a17cabe BSPYOCTOIMX6-1158 media: mt9p031: Make pixel clock polarity configurable by DT
 bf101696578a BSPYOCTOIMX6-1158 media: mt9p031: Implement [gs]_register debug calls
 2bc8b26ed123 BSPYOCTOIMX6-1158 media: mt9p031: Read back the real clock rate
 5d21adf21269 BSPYOCTOIMX6-1158 media: mt9p031: Add support for 8 bit and 10 bit formats
 01fb514b4094 ARM: configs: Increase default cma size to 256M
 35320dc15f46 ARM: configs: port configs from tag v4.19.100-phy2
 46e60368757f BSPYOCTOIMX6-1033 UPSTREAM: i2c: imx: implement master_xfer_atomic callback
 0c37d9447dbc BSPYOCTOIMX6-1030 nvmem: core: Fix nvmem binding compatibility problem

 .gitignore                                        |    4 +
 arch/arm/boot/dts/Makefile                        |   15 +-
 arch/arm/boot/dts/imx25.dtsi                      |    4 +-
 arch/arm/boot/dts/imx31.dtsi                      |    4 +-
 arch/arm/boot/dts/imx35.dtsi                      |    4 +-
 arch/arm/boot/dts/imx50.dtsi                      |    4 +-
 arch/arm/boot/dts/imx51.dtsi                      |    4 +-
 arch/arm/boot/dts/imx53.dtsi                      |    4 +-
 .../boot/dts/imx6dl-phytec-mira-ff-rdk-emmc.dts   |   82 ++
 .../boot/dts/imx6dl-phytec-mira-ff-rdk-nand.dts   |   78 ++
 .../boot/dts/imx6dl-phytec-mira-lc-rdk-emmc.dts   |   74 +
 ...and.dts => imx6dl-phytec-mira-lc-rdk-nand.dts} |    8 +-
 arch/arm/boot/dts/imx6dl.dtsi                     |    4 +-
 ...emmc.dts => imx6q-phytec-mira-ff-rdk-emmc.dts} |   12 +-
 .../dts/imx6q-phytec-mira-ff-rdk-nand-rs485.dts   |   91 ++
 ...nand.dts => imx6q-phytec-mira-ff-rdk-nand.dts} |   12 +-
 arch/arm/boot/dts/imx6q.dtsi                      |    2 +-
 .../boot/dts/imx6qdl-phytec-mira-peb-av-02.dtsi   |  121 ++
 .../boot/dts/imx6qdl-phytec-mira-peb-eval-01.dtsi |   72 +
 arch/arm/boot/dts/imx6qdl-phytec-mira.dtsi        |   98 +-
 arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi      |    3 +-
 arch/arm/boot/dts/imx6qdl-phytec-phycore-som.dtsi |   80 +-
 arch/arm/boot/dts/imx6qdl.dtsi                    |    4 +-
 ...and.dts => imx6qp-phytec-mira-ff-rdk-nand.dts} |   12 +-
 arch/arm/boot/dts/imx6qp.dtsi                     |    2 +-
 arch/arm/boot/dts/imx6sl.dtsi                     |    4 +-
 arch/arm/boot/dts/imx6sll.dtsi                    |    4 +-
 arch/arm/boot/dts/imx6sx.dtsi                     |    6 +-
 arch/arm/boot/dts/imx6ul-phytec-peb-wlbt-01.dtsi  |   66 +
 arch/arm/boot/dts/imx6ul-phytec-peb-wlbt-05.dtsi  |   87 ++
 arch/arm/boot/dts/imx6ul-phytec-phycore-som.dtsi  |   33 +
 .../boot/dts/imx6ul-phytec-segin-ff-rdk-emmc.dts  |   94 ++
 .../dts/imx6ul-phytec-segin-ff-rdk-nand-rs485.dts |  109 ++
 .../boot/dts/imx6ul-phytec-segin-ff-rdk-nand.dts  |    3 +
 .../boot/dts/imx6ul-phytec-segin-peb-av-02.dtsi   |  106 ++
 arch/arm/boot/dts/imx6ul-phytec-segin.dtsi        |   21 +-
 arch/arm/boot/dts/imx6ul.dtsi                     |    4 +-
 .../dts/imx6ull-phytec-consolinno-basemodule.dts  |  344 +++++
 arch/arm/boot/dts/imx6ull-phytec-peb-wlbt-01.dtsi |   28 +
 arch/arm/boot/dts/imx6ull-phytec-peb-wlbt-05.dtsi |   20 +
 arch/arm/boot/dts/imx6ull-phytec-phycore-som.dtsi |   11 +
 .../boot/dts/imx6ull-phytec-segin-ff-rdk-emmc.dts |    1 +
 .../boot/dts/imx6ull-phytec-segin-ff-rdk-nand.dts |    3 +
 .../boot/dts/imx6ull-phytec-segin-peb-av-02.dtsi  |   19 +
 arch/arm/boot/dts/imx6ull.dtsi                    |    2 +-
 arch/arm/boot/dts/imx7s.dtsi                      |    6 +-
 arch/arm/boot/dts/vf500.dtsi                      |    4 +-
 arch/arm/boot/dts/vfxxx.dtsi                      |    4 +-
 arch/arm/configs/imx6_phytec_distro.config        |   12 +
 arch/arm/configs/imx6_phytec_machine.config       |    5 +
 arch/arm/configs/imx6_phytec_platform.config      |   10 +
 .../imx6ull_consolinno_basemodule_defconfig       |  632 +++++++++
 arch/arm/mach-imx/Makefile                        |    1 +
 arch/arm/mach-imx/common.h                        |    1 +
 arch/arm/mach-imx/mach-imx6q.c                    |    1 +
 arch/arm/mach-imx/mach-imx6sl.c                   |    1 +
 arch/arm/mach-imx/mach-imx6sx.c                   |    1 +
 arch/arm/mach-imx/mach-imx6ul.c                   |   16 +-
 arch/arm/mach-imx/ocotp.c                         |   46 +
 drivers/cpufreq/imx6q-cpufreq.c                   |   63 +
 drivers/gpio/Kconfig                              |    6 +
 drivers/gpio/Makefile                             |    2 +
 drivers/gpio/gpio-conegx.c                        | 1334 +++++++++++++++++++
 drivers/gpio/gpio-conegx.h                        |  305 +++++
 drivers/i2c/busses/i2c-imx.c                      |  146 +-
 drivers/iio/adc/vf610_adc.c                       |   10 +-
 drivers/input/touchscreen/stmpe-ts.c              |    7 +-
 drivers/media/i2c/Kconfig                         |    1 +
 drivers/media/i2c/mt9p031.c                       |  106 +-
 drivers/mmc/core/host.c                           |   26 +-
 drivers/mtd/nand/raw/gpmi-nand/gpmi-nand.c        |   19 +-
 drivers/net/ethernet/freescale/fec_main.c         |    6 +
 drivers/nfc/Kconfig                               |   11 +
 drivers/nfc/Makefile                              |    1 +
 drivers/nfc/st25dv.c                              |  540 ++++++++
 drivers/nvmem/core.c                              |    2 +
 include/media/i2c/mt9p031.h                       |    1 +
 77 files changed, 4956 insertions(+), 133 deletions(-)
 create mode 100644 arch/arm/boot/dts/imx6dl-phytec-mira-ff-rdk-emmc.dts
 create mode 100644 arch/arm/boot/dts/imx6dl-phytec-mira-ff-rdk-nand.dts
 create mode 100644 arch/arm/boot/dts/imx6dl-phytec-mira-lc-rdk-emmc.dts
 rename arch/arm/boot/dts/{imx6dl-phytec-mira-rdk-nand.dts => imx6dl-phytec-mira-lc-rdk-nand.dts} (79%)
 rename arch/arm/boot/dts/{imx6q-phytec-mira-rdk-emmc.dts => imx6q-phytec-mira-ff-rdk-emmc.dts} (78%)
 create mode 100644 arch/arm/boot/dts/imx6q-phytec-mira-ff-rdk-nand-rs485.dts
 rename arch/arm/boot/dts/{imx6q-phytec-mira-rdk-nand.dts => imx6q-phytec-mira-ff-rdk-nand.dts} (78%)
 create mode 100644 arch/arm/boot/dts/imx6qdl-phytec-mira-peb-av-02.dtsi
 create mode 100644 arch/arm/boot/dts/imx6qdl-phytec-mira-peb-eval-01.dtsi
 rename arch/arm/boot/dts/{imx6qp-phytec-mira-rdk-nand.dts => imx6qp-phytec-mira-ff-rdk-nand.dts} (78%)
 create mode 100644 arch/arm/boot/dts/imx6ul-phytec-peb-wlbt-01.dtsi
 create mode 100644 arch/arm/boot/dts/imx6ul-phytec-peb-wlbt-05.dtsi
 create mode 100644 arch/arm/boot/dts/imx6ul-phytec-segin-ff-rdk-emmc.dts
 create mode 100644 arch/arm/boot/dts/imx6ul-phytec-segin-ff-rdk-nand-rs485.dts
 create mode 100644 arch/arm/boot/dts/imx6ul-phytec-segin-peb-av-02.dtsi
 create mode 100644 arch/arm/boot/dts/imx6ull-phytec-consolinno-basemodule.dts
 create mode 100644 arch/arm/boot/dts/imx6ull-phytec-peb-wlbt-01.dtsi
 create mode 100644 arch/arm/boot/dts/imx6ull-phytec-peb-wlbt-05.dtsi
 create mode 100644 arch/arm/boot/dts/imx6ull-phytec-segin-peb-av-02.dtsi
 create mode 100644 arch/arm/configs/imx6_phytec_distro.config
 create mode 100644 arch/arm/configs/imx6_phytec_machine.config
 create mode 100644 arch/arm/configs/imx6_phytec_platform.config
 create mode 100644 arch/arm/configs/imx6ull_consolinno_basemodule_defconfig
 create mode 100644 arch/arm/mach-imx/ocotp.c
 create mode 100644 drivers/gpio/gpio-conegx.c
 create mode 100644 drivers/gpio/gpio-conegx.h
 create mode 100644 drivers/nfc/st25dv.c

diff --git a/.gitignore b/.gitignore
index 70580bdd352c..964c8e26ebe8 100644
--- a/.gitignore
+++ b/.gitignore
@@ -146,3 +146,7 @@ x509.genkey
 
 # Clang's compilation database file
 /compile_commands.json
+
+# local install directory
+kernel-install
+build-kernel.sh
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index b21b3a64641a..44b9c75bfeb0 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -430,7 +430,10 @@ dtb-$(CONFIG_SOC_IMX6Q) += \
 	imx6dl-mamoj.dtb \
 	imx6dl-nit6xlite.dtb \
 	imx6dl-nitrogen6x.dtb \
-	imx6dl-phytec-mira-rdk-nand.dtb \
+	imx6dl-phytec-mira-ff-rdk-emmc.dts \
+	imx6dl-phytec-mira-ff-rdk-nand.dts \
+	imx6dl-phytec-mira-lc-rdk-emmc.dts \
+	imx6dl-phytec-mira-lc-rdk-nand.dts \
 	imx6dl-phytec-pbab01.dtb \
 	imx6dl-rex-basic.dtb \
 	imx6dl-riotboard.dtb \
@@ -508,8 +511,9 @@ dtb-$(CONFIG_SOC_IMX6Q) += \
 	imx6q-nitrogen6_max.dtb \
 	imx6q-nitrogen6_som2.dtb \
 	imx6q-novena.dtb \
-	imx6q-phytec-mira-rdk-emmc.dtb \
-	imx6q-phytec-mira-rdk-nand.dtb \
+	imx6q-phytec-mira-ff-rdk-emmc.dts \
+	imx6q-phytec-mira-ff-rdk-nand-rs485.dts \
+	imx6q-phytec-mira-ff-rdk-nand.dts \
 	imx6q-phytec-pbab01.dtb \
 	imx6q-pistachio.dtb \
 	imx6q-rex-pro.dtb \
@@ -539,7 +543,7 @@ dtb-$(CONFIG_SOC_IMX6Q) += \
 	imx6q-zii-rdu2.dtb \
 	imx6qp-nitrogen6_max.dtb \
 	imx6qp-nitrogen6_som2.dtb \
-	imx6qp-phytec-mira-rdk-nand.dtb \
+	imx6qp-phytec-mira-ff-rdk-nand.dts \
 	imx6qp-sabreauto.dtb \
 	imx6qp-sabresd.dtb \
 	imx6qp-tx6qp-8037.dtb \
@@ -576,6 +580,8 @@ dtb-$(CONFIG_SOC_IMX6UL) += \
 	imx6ul-opos6uldev.dtb \
 	imx6ul-pico-hobbit.dtb \
 	imx6ul-pico-pi.dtb \
+	imx6ul-phytec-segin-ff-rdk-emmc.dtb \
+	imx6ul-phytec-segin-ff-rdk-nand-rs485.dtb \
 	imx6ul-phytec-segin-ff-rdk-nand.dtb \
 	imx6ul-tx6ul-0010.dtb \
 	imx6ul-tx6ul-0011.dtb \
@@ -583,6 +589,7 @@ dtb-$(CONFIG_SOC_IMX6UL) += \
 	imx6ull-14x14-evk.dtb \
 	imx6ull-colibri-eval-v3.dtb \
 	imx6ull-colibri-wifi-eval-v3.dtb \
+	imx6ull-phytec-consolinno-basemodule.dtb \
 	imx6ull-phytec-segin-ff-rdk-nand.dtb \
 	imx6ull-phytec-segin-ff-rdk-emmc.dtb \
 	imx6ull-phytec-segin-lc-rdk-nand.dtb \
diff --git a/arch/arm/boot/dts/imx25.dtsi b/arch/arm/boot/dts/imx25.dtsi
index 9a097ef014af..d79e3d151b16 100644
--- a/arch/arm/boot/dts/imx25.dtsi
+++ b/arch/arm/boot/dts/imx25.dtsi
@@ -75,7 +75,7 @@
 		interrupt-parent = <&asic>;
 		ranges;
 
-		aips@43f00000 { /* AIPS1 */
+		bus@43f00000 { /* AIPS1 */
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -332,7 +332,7 @@
 			};
 		};
 
-		aips@53f00000 { /* AIPS2 */
+		bus@53f00000 { /* AIPS2 */
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/boot/dts/imx31.dtsi b/arch/arm/boot/dts/imx31.dtsi
index d7f6fb764997..0811f3cb97bf 100644
--- a/arch/arm/boot/dts/imx31.dtsi
+++ b/arch/arm/boot/dts/imx31.dtsi
@@ -63,7 +63,7 @@
 			ranges = <0 0x1fffc000 0x4000>;
 		};
 
-		aips@43f00000 { /* AIPS1 */
+		bus@43f00000 { /* AIPS1 */
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -225,7 +225,7 @@
 			};
 		};
 
-		aips@53f00000 { /* AIPS2 */
+		bus@53f00000 { /* AIPS2 */
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/boot/dts/imx35.dtsi b/arch/arm/boot/dts/imx35.dtsi
index 9cbdc1a15cda..2ebf2c1fa682 100644
--- a/arch/arm/boot/dts/imx35.dtsi
+++ b/arch/arm/boot/dts/imx35.dtsi
@@ -66,7 +66,7 @@
 			cache-level = <2>;
 		};
 
-		aips1: aips@43f00000 {
+		aips1: bus@43f00000 {
 			compatible = "fsl,aips", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -199,7 +199,7 @@
 			};
 		};
 
-		aips2: aips@53f00000 {
+		aips2: bus@53f00000 {
 			compatible = "fsl,aips", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/boot/dts/imx50.dtsi b/arch/arm/boot/dts/imx50.dtsi
index 0bfe7c91d0eb..d325658901c5 100644
--- a/arch/arm/boot/dts/imx50.dtsi
+++ b/arch/arm/boot/dts/imx50.dtsi
@@ -101,7 +101,7 @@
 		interrupt-parent = <&tzic>;
 		ranges;
 
-		aips@50000000 { /* AIPS1 */
+		bus@50000000 { /* AIPS1 */
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -389,7 +389,7 @@
 			};
 		};
 
-		aips@60000000 {	/* AIPS2 */
+		bus@60000000 {	/* AIPS2 */
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/boot/dts/imx51.dtsi b/arch/arm/boot/dts/imx51.dtsi
index 0a4b9a5d9a9c..94671899454c 100644
--- a/arch/arm/boot/dts/imx51.dtsi
+++ b/arch/arm/boot/dts/imx51.dtsi
@@ -158,7 +158,7 @@
 			};
 		};
 
-		aips@70000000 { /* AIPS1 */
+		bus@70000000 { /* AIPS1 */
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -440,7 +440,7 @@
 			};
 		};
 
-		aips@80000000 {	/* AIPS2 */
+		bus@80000000 {	/* AIPS2 */
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/boot/dts/imx53.dtsi b/arch/arm/boot/dts/imx53.dtsi
index ed341cfd9d09..8536f59f59e6 100644
--- a/arch/arm/boot/dts/imx53.dtsi
+++ b/arch/arm/boot/dts/imx53.dtsi
@@ -222,7 +222,7 @@
 			clock-names = "core_clk", "mem_iface_clk";
 		};
 
-		aips@50000000 { /* AIPS1 */
+		bus@50000000 { /* AIPS1 */
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -654,7 +654,7 @@
 			};
 		};
 
-		aips@60000000 {	/* AIPS2 */
+		bus@60000000 {	/* AIPS2 */
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/boot/dts/imx6dl-phytec-mira-ff-rdk-emmc.dts b/arch/arm/boot/dts/imx6dl-phytec-mira-ff-rdk-emmc.dts
new file mode 100644
index 000000000000..fc2e467fd3e4
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dl-phytec-mira-ff-rdk-emmc.dts
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2018 PHYTEC Messtechnik GmbH
+ * Author: Christian Hemp <c.hemp@phytec.de>
+ */
+
+/dts-v1/;
+#include "imx6dl.dtsi"
+#include "imx6qdl-phytec-phycore-som.dtsi"
+#include "imx6qdl-phytec-mira.dtsi"
+#include "imx6qdl-phytec-mira-peb-eval-01.dtsi"
+#include "imx6qdl-phytec-mira-peb-av-02.dtsi"
+
+/ {
+	model = "PHYTEC phyBOARD-Mira DualLight/Solo full featured with eMMC";
+	compatible = "phytec,imx6dl-pbac06-emmc", "phytec,imx6dl-pbac06",
+		     "phytec,imx6qdl-pcm058", "fsl,imx6dl";
+
+	chosen {
+		stdout-path = &uart2;
+	};
+};
+
+&can1 {
+	status = "okay";
+};
+
+&dim_gpio_leds {
+	status = "okay";
+};
+
+&fec {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&i2c1 {
+	status = "okay";
+};
+
+&i2c2 {
+	status = "okay";
+};
+
+&i2c_rtc {
+	status = "okay";
+};
+
+&leddim {
+	status = "okay";
+};
+
+&m25p80 {
+	status = "okay";
+};
+
+&pcie {
+	status = "okay";
+};
+
+&uart3 {
+	status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	status = "okay";
+};
+
+&usdhc1 {
+	status = "okay";
+};
+
+&usdhc4 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/imx6dl-phytec-mira-ff-rdk-nand.dts b/arch/arm/boot/dts/imx6dl-phytec-mira-ff-rdk-nand.dts
new file mode 100644
index 000000000000..11666886bc2c
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dl-phytec-mira-ff-rdk-nand.dts
@@ -0,0 +1,78 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2018 PHYTEC Messtechnik GmbH
+ * Author: Christian Hemp <c.hemp@phytec.de>
+ */
+
+/dts-v1/;
+#include "imx6dl.dtsi"
+#include "imx6qdl-phytec-phycore-som.dtsi"
+#include "imx6qdl-phytec-mira.dtsi"
+#include "imx6qdl-phytec-mira-peb-eval-01.dtsi"
+#include "imx6qdl-phytec-mira-peb-av-02.dtsi"
+
+/ {
+	model = "PHYTEC phyBOARD-Mira DualLight/Solo full featured with NAND";
+	compatible = "phytec,imx6dl-pbac06-nand", "phytec,imx6dl-pbac06",
+		     "phytec,imx6qdl-pcm058", "fsl,imx6dl";
+
+	chosen {
+		linux,stdout-path = &uart2;
+	};
+};
+
+&can1 {
+	status = "okay";
+};
+
+&dim_gpio_leds {
+	status = "okay";
+};
+
+&fec {
+	status = "okay";
+};
+
+&gpmi {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&i2c1 {
+	status = "okay";
+};
+
+&i2c2 {
+	status = "okay";
+};
+
+&i2c_rtc {
+	status = "okay";
+};
+
+&leddim {
+	status = "okay";
+};
+
+&pcie {
+	status = "okay";
+};
+
+&uart3 {
+	status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	status = "okay";
+};
+
+&usdhc1 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/imx6dl-phytec-mira-lc-rdk-emmc.dts b/arch/arm/boot/dts/imx6dl-phytec-mira-lc-rdk-emmc.dts
new file mode 100644
index 000000000000..47e6a4b57bd4
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dl-phytec-mira-lc-rdk-emmc.dts
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2018 PHYTEC Messtechnik
+ * Author: Stefan Christ <s.christ@phytec.de>
+ */
+
+/dts-v1/;
+#include "imx6dl.dtsi"
+#include "imx6qdl-phytec-phycore-som.dtsi"
+#include "imx6qdl-phytec-mira.dtsi"
+#include "imx6qdl-phytec-mira-peb-eval-01.dtsi"
+#include "imx6qdl-phytec-mira-peb-av-02.dtsi"
+
+/ {
+	model = "PHYTEC phyBOARD-Mira DualLite/Solo low cost with eMMC";
+	compatible = "phytec,imx6dl-pbac06-emmc", "phytec,imx6dl-pbac06",
+		     "phytec,imx6qdl-pcm058", "fsl,imx6dl";
+
+	chosen {
+		stdout-path = &uart2;
+	};
+};
+
+&ethphy {
+	max-speed = <100>;
+};
+
+&fec {
+	status = "okay";
+};
+
+&gpio_leds {
+	status = "okay";
+};
+
+&m25p80 {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&i2c1 {
+	status = "okay";
+};
+
+&i2c2 {
+	status = "okay";
+};
+
+&i2c_rtc {
+	status = "okay";
+};
+
+&uart3 {
+	status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	status = "okay";
+};
+
+&usdhc1 {
+	status = "okay";
+};
+
+&usdhc4 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/imx6dl-phytec-mira-rdk-nand.dts b/arch/arm/boot/dts/imx6dl-phytec-mira-lc-rdk-nand.dts
similarity index 79%
rename from arch/arm/boot/dts/imx6dl-phytec-mira-rdk-nand.dts
rename to arch/arm/boot/dts/imx6dl-phytec-mira-lc-rdk-nand.dts
index 9f7f9f98139d..7e0f75825b1e 100644
--- a/arch/arm/boot/dts/imx6dl-phytec-mira-rdk-nand.dts
+++ b/arch/arm/boot/dts/imx6dl-phytec-mira-lc-rdk-nand.dts
@@ -8,9 +8,11 @@
 #include "imx6dl.dtsi"
 #include "imx6qdl-phytec-phycore-som.dtsi"
 #include "imx6qdl-phytec-mira.dtsi"
+#include "imx6qdl-phytec-mira-peb-eval-01.dtsi"
+#include "imx6qdl-phytec-mira-peb-av-02.dtsi"
 
 / {
-	model = "PHYTEC phyBOARD-Mira DualLite/Solo Carrier-Board with NAND";
+	model = "PHYTEC phyBOARD-Mira DualLite/Solo low cost with NAND";
 	compatible = "phytec,imx6dl-pbac06-nand", "phytec,imx6dl-pbac06",
 		     "phytec,imx6qdl-pcm058", "fsl,imx6dl";
 
@@ -27,6 +29,10 @@
 	status = "okay";
 };
 
+&gpio_leds {
+	status = "okay";
+};
+
 &gpmi {
 	status = "okay";
 };
diff --git a/arch/arm/boot/dts/imx6dl.dtsi b/arch/arm/boot/dts/imx6dl.dtsi
index 4bde98033ff4..e87e20b7b728 100644
--- a/arch/arm/boot/dts/imx6dl.dtsi
+++ b/arch/arm/boot/dts/imx6dl.dtsi
@@ -87,7 +87,7 @@
 			clocks = <&clks IMX6QDL_CLK_OCRAM>;
 		};
 
-		aips1: aips-bus@2000000 {
+		aips1: bus@2000000 {
 			iomuxc: iomuxc@20e0000 {
 				compatible = "fsl,imx6dl-iomuxc";
 			};
@@ -103,7 +103,7 @@
 			};
 		};
 
-		aips2: aips-bus@2100000 {
+		aips2: bus@2100000 {
 			i2c4: i2c@21f8000 {
 				#address-cells = <1>;
 				#size-cells = <0>;
diff --git a/arch/arm/boot/dts/imx6q-phytec-mira-rdk-emmc.dts b/arch/arm/boot/dts/imx6q-phytec-mira-ff-rdk-emmc.dts
similarity index 78%
rename from arch/arm/boot/dts/imx6q-phytec-mira-rdk-emmc.dts
rename to arch/arm/boot/dts/imx6q-phytec-mira-ff-rdk-emmc.dts
index 2e70ea5623c6..2f2432f8b862 100644
--- a/arch/arm/boot/dts/imx6q-phytec-mira-rdk-emmc.dts
+++ b/arch/arm/boot/dts/imx6q-phytec-mira-ff-rdk-emmc.dts
@@ -8,9 +8,11 @@
 #include "imx6q.dtsi"
 #include "imx6qdl-phytec-phycore-som.dtsi"
 #include "imx6qdl-phytec-mira.dtsi"
+#include "imx6qdl-phytec-mira-peb-eval-01.dtsi"
+#include "imx6qdl-phytec-mira-peb-av-02.dtsi"
 
 / {
-	model = "PHYTEC phyBOARD-Mira Quad Carrier-Board with eMMC";
+	model = "PHYTEC phyBOARD-Mira Quad full featured with eMMC";
 	compatible = "phytec,imx6q-pbac06-emmc", "phytec,imx6q-pbac06",
 		     "phytec,imx6qdl-pcm058", "fsl,imx6q";
 
@@ -23,6 +25,10 @@
 	status = "okay";
 };
 
+&dim_gpio_leds {
+	status = "okay";
+};
+
 &fec {
 	status = "okay";
 };
@@ -43,6 +49,10 @@
 	status = "okay";
 };
 
+&leddim {
+	status = "okay";
+};
+
 &m25p80 {
 	status = "okay";
 };
diff --git a/arch/arm/boot/dts/imx6q-phytec-mira-ff-rdk-nand-rs485.dts b/arch/arm/boot/dts/imx6q-phytec-mira-ff-rdk-nand-rs485.dts
new file mode 100644
index 000000000000..c5b976042db4
--- /dev/null
+++ b/arch/arm/boot/dts/imx6q-phytec-mira-ff-rdk-nand-rs485.dts
@@ -0,0 +1,91 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2018 PHYTEC Messtechnik GmbH
+ * Author: Christian Hemp <c.hemp@phytec.de>
+ */
+
+/dts-v1/;
+#include "imx6q.dtsi"
+#include "imx6qdl-phytec-phycore-som.dtsi"
+#include "imx6qdl-phytec-mira.dtsi"
+#include "imx6qdl-phytec-mira-peb-eval-01.dtsi"
+#include "imx6qdl-phytec-mira-peb-av-02.dtsi"
+
+/ {
+	model = "PHYTEC phyBOARD-MIRA Quad full-featured with NAND and RS485";
+	compatible = "phytec,imx6q-pbac06-nand", "phytec,imx6q-pbac06",
+		     "phytec,imx6qdl-pcm058", "fsl,imx6q";
+
+	chosen {
+		stdout-path = &uart2;
+	};
+};
+
+&can1 {
+	status = "okay";
+};
+
+&fec {
+	status = "okay";
+};
+
+&gpmi {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&i2c1 {
+	status = "okay";
+};
+
+&i2c2 {
+	status = "okay";
+};
+
+&i2c_rtc {
+	status = "okay";
+};
+
+&leddim {
+	status = "okay";
+};
+
+&m25p80 {
+	status = "okay";
+};
+
+&pcie {
+	status = "okay";
+};
+
+&uart3 {
+	rts-gpios = <&gpio3 23 GPIO_ACTIVE_HIGH>;
+	linux,rs485-enabled-at-boot-time;
+	rs485-rts-active-high;
+	status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	status = "okay";
+};
+
+&usdhc1 {
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			MX6QDL_PAD_EIM_D23__GPIO3_IO23		0x1a0b1
+			MX6QDL_PAD_EIM_D24__UART3_TX_DATA	0x1b0b1
+			MX6QDL_PAD_EIM_D25__UART3_RX_DATA	0x1b0b1
+		>;
+	};
+};
diff --git a/arch/arm/boot/dts/imx6q-phytec-mira-rdk-nand.dts b/arch/arm/boot/dts/imx6q-phytec-mira-ff-rdk-nand.dts
similarity index 78%
rename from arch/arm/boot/dts/imx6q-phytec-mira-rdk-nand.dts
rename to arch/arm/boot/dts/imx6q-phytec-mira-ff-rdk-nand.dts
index 65d2e483c136..0c3d8c70bf71 100644
--- a/arch/arm/boot/dts/imx6q-phytec-mira-rdk-nand.dts
+++ b/arch/arm/boot/dts/imx6q-phytec-mira-ff-rdk-nand.dts
@@ -8,9 +8,11 @@
 #include "imx6q.dtsi"
 #include "imx6qdl-phytec-phycore-som.dtsi"
 #include "imx6qdl-phytec-mira.dtsi"
+#include "imx6qdl-phytec-mira-peb-eval-01.dtsi"
+#include "imx6qdl-phytec-mira-peb-av-02.dtsi"
 
 / {
-	model = "PHYTEC phyBOARD-Mira Quad Carrier-Board with NAND";
+	model = "PHYTEC phyBOARD-Mira Quad full featured with NAND";
 	compatible = "phytec,imx6q-pbac06-nand", "phytec,imx6q-pbac06",
 		     "phytec,imx6qdl-pcm058", "fsl,imx6q";
 
@@ -23,6 +25,10 @@
 	status = "okay";
 };
 
+&dim_gpio_leds {
+	status = "okay";
+};
+
 &fec {
 	status = "okay";
 };
@@ -47,6 +53,10 @@
 	status = "okay";
 };
 
+&leddim {
+	status = "okay";
+};
+
 &m25p80 {
 	status = "okay";
 };
diff --git a/arch/arm/boot/dts/imx6q.dtsi b/arch/arm/boot/dts/imx6q.dtsi
index 013080e709f8..e18f7f3f4ab9 100644
--- a/arch/arm/boot/dts/imx6q.dtsi
+++ b/arch/arm/boot/dts/imx6q.dtsi
@@ -164,7 +164,7 @@
 			clocks = <&clks IMX6QDL_CLK_OCRAM>;
 		};
 
-		aips-bus@2000000 { /* AIPS1 */
+		bus@2000000 { /* AIPS1 */
 			spba-bus@2000000 {
 				ecspi5: spi@2018000 {
 					#address-cells = <1>;
diff --git a/arch/arm/boot/dts/imx6qdl-phytec-mira-peb-av-02.dtsi b/arch/arm/boot/dts/imx6qdl-phytec-mira-peb-av-02.dtsi
new file mode 100644
index 000000000000..7b4af306b023
--- /dev/null
+++ b/arch/arm/boot/dts/imx6qdl-phytec-mira-peb-av-02.dtsi
@@ -0,0 +1,121 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2018 PHYTEC Messtechnik
+ * Author: Christian Hemp <c.hemp@phytec.de>
+ */
+
+/ {
+
+	display: display@di0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "fsl,imx-parallel-display";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_disp0>;
+		status = "disabled";
+
+		port@0 {
+			reg = <0>;
+
+			display0_in: endpoint {
+				remote-endpoint = <&ipu1_di0_disp0>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+
+			display0_out: endpoint {
+				remote-endpoint = <&peb_panel_lcd_in>;
+			};
+		};
+	};
+
+	panel-lcd {
+		compatible = "edt,etm0700g0edh6";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_disp0_pwr>;
+		power-supply = <&reg_display>;
+		enable-gpios = <&gpio3 22 GPIO_ACTIVE_HIGH>;
+		backlight = <&backlight>;
+		status = "disabled";
+
+		port {
+			peb_panel_lcd_in: endpoint {
+				remote-endpoint = <&display0_out>;
+			};
+		};
+	};
+
+	reg_display: regulator-peb-display {
+		compatible = "regulator-fixed";
+		regulator-name = "peb-display";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+};
+
+&i2c1 {
+	edt_ft5x06: polytouch@38 {
+		compatible = "edt,edt-ft5406", "edt,edt-ft5x06";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_edt_ft5x06>;
+		reg = <0x38>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <2 IRQ_TYPE_NONE>;
+		status = "disabled";
+        };
+};
+
+&ipu1_di0_disp0 {
+	remote-endpoint = <&display0_in>;
+};
+
+&iomuxc {
+	pinctrl_disp0: disp0grp {
+		fsl,pins = <
+			MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK	0x10
+			MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02		0x10
+			MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03		0x10
+
+			MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15		0x1b080
+
+			MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00	0x10
+			MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01	0x10
+			MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02	0x10
+			MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03	0x10
+			MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04	0x10
+			MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05	0x10
+			MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06	0x10
+			MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07	0x10
+			MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08	0x10
+			MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09	0x10
+			MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10	0x10
+			MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11	0x10
+			MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12	0x10
+			MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13	0x10
+			MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14	0x10
+			MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15	0x10
+			MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16	0x10
+			MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17	0x10
+			MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18	0x10
+			MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19	0x10
+			MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20	0x10
+			MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21	0x10
+			MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22	0x10
+			MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23	0x10
+		>;
+	};
+
+	pinctrl_disp0_pwr: disp0pwrgrp {
+		fsl,pins = <
+			MX6QDL_PAD_EIM_D22__GPIO3_IO22			0x1b0b0
+		>;
+	};
+
+	pinctrl_edt_ft5x06: edtft5x06grp {
+		fsl,pins = <
+			MX6QDL_PAD_EIM_DA2__GPIO3_IO02			0xb0b1
+		>;
+	};
+};
diff --git a/arch/arm/boot/dts/imx6qdl-phytec-mira-peb-eval-01.dtsi b/arch/arm/boot/dts/imx6qdl-phytec-mira-peb-eval-01.dtsi
new file mode 100644
index 000000000000..c4127c392a42
--- /dev/null
+++ b/arch/arm/boot/dts/imx6qdl-phytec-mira-peb-eval-01.dtsi
@@ -0,0 +1,72 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2018 PHYTEC Messtechnik
+ * Author: Christian Hemp <c.hemp@phytec.de>
+ */
+
+#include <dt-bindings/input/input.h>
+
+/ {
+	gpio-keys {
+		compatible = "gpio-key";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_keys>;
+		status = "disabled";
+
+		home {
+			label = "Home";
+			gpios = <&gpio6 18 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_SLEEP>;
+			wakeup-source;
+		};
+
+		power {
+			label = "Power Button";
+			gpios = <&gpio5 28 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_WAKEUP>;
+			wakeup-source;
+		};
+	};
+
+	user_leds: user-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_user_leds>;
+		status = "disabled";
+
+		user-led1 {
+			gpios = <&gpio7 1 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "gpio";
+			default-state = "on";
+		};
+
+		user-led2 {
+			gpios = <&gpio7 0 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "gpio";
+			default-state = "on";
+		};
+
+		user-led3 {
+			gpios = <&gpio5 29 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "gpio";
+			default-state = "on";
+		};
+	};
+};
+
+&iomuxc {
+	pinctrl_gpio_keys: gpiokeysgrp {
+		fsl,pins = <
+			MX6QDL_PAD_SD3_DAT6__GPIO6_IO18		0x1b0b0
+			MX6QDL_PAD_CSI0_DAT10__GPIO5_IO28	0x1b0b0
+		>;
+	};
+
+	pinctrl_user_leds: userledsgrp {
+		fsl,pins = <
+			MX6QDL_PAD_SD3_DAT4__GPIO7_IO01		0x1b0b0
+			MX6QDL_PAD_SD3_DAT5__GPIO7_IO00		0x1b0b0
+			MX6QDL_PAD_CSI0_DAT11__GPIO5_IO29	0x1b0b0
+		>;
+	};
+};
diff --git a/arch/arm/boot/dts/imx6qdl-phytec-mira.dtsi b/arch/arm/boot/dts/imx6qdl-phytec-mira.dtsi
index 9ebd438dce7d..329cfbb03382 100644
--- a/arch/arm/boot/dts/imx6qdl-phytec-mira.dtsi
+++ b/arch/arm/boot/dts/imx6qdl-phytec-mira.dtsi
@@ -4,6 +4,7 @@
  * Author: Christian Hemp <c.hemp@phytec.de>
  */
 
+#include <dt-bindings/leds/leds-pca9532.h>
 
 / {
 	aliases {
@@ -19,24 +20,71 @@
 		status = "okay";
 	};
 
+	csi_deserializer0: csi_deserializer0 {
+		compatible = "ti,scan921226h";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi_des0>;
+		status = "okay";
+
+		enable-gpios = <&gpio5 20 GPIO_ACTIVE_HIGH>;
+		npwrdn-gpios = <&gpio3 9 GPIO_ACTIVE_HIGH>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		/* serial sink interface */
+		port@0 {
+			reg = <0>;
+
+			des0_in: endpoint {
+			};
+		};
+
+		/* parallel source interface */
+		port@1 {
+			reg = <1>;
+
+			des0_out: endpoint {
+			};
+		};
+	};
+
+	dim_gpio_leds: dimleds {
+		compatible = "gpio-leds";
+		status = "disabled";
+
+		mira-red {
+			gpios = <&leddim 0 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "none";
+		};
+
+		mira-green {
+			gpios = <&leddim 1 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "none";
+		};
+
+		mira-blue {
+			gpios = <&leddim 2 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "mmc0";
+			default-state = "on";
+		};
+	};
+
 	gpio_leds: leds {
 		compatible = "gpio-leds";
 		pinctrl-names = "default";
 		pinctrl-0 = <&pinctrl_gpioleds>;
 		status = "disabled";
 
-		red {
-			label = "phyboard-mira:red";
+		mira-red {
 			gpios = <&gpio5 22 GPIO_ACTIVE_HIGH>;
 		};
 
-		green {
-			label = "phyboard-mira:green";
+		mira-green {
 			gpios = <&gpio5 23 GPIO_ACTIVE_HIGH>;
 		};
 
-		blue {
-			label = "phyboard-mira:blue";
+		mira-blue {
 			gpios = <&gpio5 24 GPIO_ACTIVE_HIGH>;
 			linux,default-trigger = "mmc0";
 		};
@@ -147,9 +195,32 @@
 &i2c1 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_i2c1>;
-	clock-frequency = <400000>;
+	clock-frequency = <100000>;
 	status = "disabled";
 
+	leddim: leddimmer@62 {
+		compatible = "nxp,pca9533";
+		gpio-controller;
+		#gpio-cells = <2>;
+		reg = <0x62>;
+		status = "disabled";
+
+		red {
+			label = "red";
+			type = <PCA9532_TYPE_GPIO>;
+		};
+
+		green {
+			label = "green";
+			type = <PCA9532_TYPE_GPIO>;
+		};
+
+		blue {
+			label = "blue";
+			type = <PCA9532_TYPE_GPIO>;
+		};
+	};
+
 	stmpe: touchctrl@44 {
 		compatible = "st,stmpe811";
 		pinctrl-names = "default";
@@ -196,7 +267,7 @@
 
 	lvds-channel@0 {
 		fsl,data-mapping = "spwg";
-		fsl,data-width = <24>;
+		fsl,data-width = <18>;
 		status = "disabled";
 
 		port@4 {
@@ -259,6 +330,13 @@
 };
 
 &iomuxc {
+	pinctrl_csi_des0: csides0grp {
+		fsl,pins = <
+			MX6QDL_PAD_CSI0_DATA_EN__GPIO5_IO20	0x4001b0b0
+			MX6QDL_PAD_EIM_DA9__GPIO3_IO09		0x4001b0b0
+		>;
+	};
+
 	pinctrl_panel_en: panelen1grp {
 		fsl,pins = <
 			MX6QDL_PAD_EIM_EB0__GPIO2_IO28		0xb0b1
@@ -351,8 +429,8 @@
 
 	pinctrl_uart3: uart3grp {
 		fsl,pins = <
-			MX6QDL_PAD_EIM_EB3__UART3_CTS_B		0x1b0b1
-			MX6QDL_PAD_EIM_D23__UART3_RTS_B		0x1b0b1
+			MX6QDL_PAD_EIM_EB3__UART3_RTS_B		0x1b0b1
+			MX6QDL_PAD_EIM_D23__UART3_CTS_B		0x1b0b1
 			MX6QDL_PAD_EIM_D24__UART3_TX_DATA	0x1b0b1
 			MX6QDL_PAD_EIM_D25__UART3_RX_DATA	0x1b0b1
 		>;
diff --git a/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi b/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi
index 3617089dbe36..5732b3e2f8ce 100644
--- a/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi
+++ b/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi
@@ -116,7 +116,8 @@
 	status = "okay";
 
 	som_eeprom: eeprom@50 {
-		compatible = "atmel,24c32";
+		compatible = "catalyst,24c32", "atmel,24c32";
+		pagesize = <32>;
 		reg = <0x50>;
 	};
 
diff --git a/arch/arm/boot/dts/imx6qdl-phytec-phycore-som.dtsi b/arch/arm/boot/dts/imx6qdl-phytec-phycore-som.dtsi
index 31fa37d2fe47..a09038adee53 100644
--- a/arch/arm/boot/dts/imx6qdl-phytec-phycore-som.dtsi
+++ b/arch/arm/boot/dts/imx6qdl-phytec-phycore-som.dtsi
@@ -10,6 +10,8 @@
 	aliases {
 		rtc1 = &da9062_rtc;
 		rtc2 = &snvs_rtc;
+		watchdog0 = &da9062_wdog;
+		watchdog1 = &wdog1;
 	};
 
 	/*
@@ -26,14 +28,17 @@
 		pinctrl-names = "default";
 		pinctrl-0 = <&pinctrl_gpioleds_som>;
 
-		som-led-green {
-			label = "phycore:green";
+		phycore-green {
 			gpios = <&gpio1 4 GPIO_ACTIVE_HIGH>;
 			linux,default-trigger = "heartbeat";
 		};
 	};
 };
 
+&cpu0 {
+	fsl,ldo-bypass;
+};
+
 &ecspi1 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_ecspi1>;
@@ -55,6 +60,7 @@
 	phy-mode = "rgmii";
 	phy-supply = <&vdd_eth_io>;
 	phy-reset-gpios = <&gpio1 14 GPIO_ACTIVE_LOW>;
+	phy-reset-duration = <10>; /* in msecs */
 	status = "disabled";
 
 	mdio {
@@ -83,7 +89,8 @@
 	status = "okay";
 
 	eeprom@50 {
-		compatible = "atmel,24c32";
+		compatible = "st,24c32", "atmel,24c32";
+		pagesize = <32>;
 		reg = <0x50>;
 	};
 
@@ -100,7 +107,7 @@
 			compatible = "dlg,da9062-rtc";
 		};
 
-		watchdog {
+		da9062_wdog: watchdog {
 			compatible = "dlg,da9062-watchdog";
 		};
 
@@ -109,28 +116,58 @@
 				regulator-name = "vdd_arm";
 				regulator-min-microvolt = <925000>;
 				regulator-max-microvolt = <1380000>;
+				regulator-ramp-delay = <2500>;
+				regulator-initial-mode = <2>; /* SYNC */
 				regulator-always-on;
+				regulator-state-standby {
+					regulator-on-in-suspend;
+				};
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
 			};
 
 			vdd_soc: buck2 {
 				regulator-name = "vdd_soc";
 				regulator-min-microvolt = <1150000>;
 				regulator-max-microvolt = <1380000>;
+				regulator-ramp-delay = <2500>;
+				regulator-initial-mode = <2>; /* SYNC */
 				regulator-always-on;
+				regulator-state-standby {
+					regulator-on-in-suspend;
+				};
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
 			};
 
 			vdd_ddr3_1p5: buck3 {
 				regulator-name = "vdd_ddr3";
 				regulator-min-microvolt = <1500000>;
 				regulator-max-microvolt = <1500000>;
+				regulator-initial-mode = <2>; /* SYNC */
 				regulator-always-on;
+				regulator-state-standby {
+					regulator-on-in-suspend;
+				};
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
 			};
 
 			vdd_eth_1p2: buck4 {
 				regulator-name = "vdd_eth";
 				regulator-min-microvolt = <1200000>;
 				regulator-max-microvolt = <1200000>;
+				regulator-initial-mode = <2>; /* SYNC */
 				regulator-always-on;
+				regulator-state-standby {
+					regulator-on-in-suspend;
+				};
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
 			};
 
 			vdd_snvs: ldo1 {
@@ -138,6 +175,12 @@
 				regulator-min-microvolt = <3000000>;
 				regulator-max-microvolt = <3000000>;
 				regulator-always-on;
+				regulator-state-standby {
+					regulator-on-in-suspend;
+				};
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
 			};
 
 			vdd_high: ldo2 {
@@ -145,32 +188,53 @@
 				regulator-min-microvolt = <3000000>;
 				regulator-max-microvolt = <3000000>;
 				regulator-always-on;
+				regulator-state-standby {
+					regulator-on-in-suspend;
+				};
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
 			};
 
 			vdd_eth_io: ldo3 {
 				regulator-name = "vdd_eth_io";
 				regulator-min-microvolt = <2500000>;
 				regulator-max-microvolt = <2500000>;
+				regulator-state-standby {
+					regulator-on-in-suspend;
+				};
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
 			};
 
 			vdd_emmc_1p8: ldo4 {
 				regulator-name = "vdd_emmc";
 				regulator-min-microvolt = <1800000>;
 				regulator-max-microvolt = <1800000>;
+				regulator-state-standby {
+					regulator-on-in-suspend;
+				};
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
 			};
 		};
 	};
 };
 
 &reg_arm {
+	regulator-allow-bypass;
 	vin-supply = <&vdd_arm>;
 };
 
 &reg_pu {
+	regulator-allow-bypass;
 	vin-supply = <&vdd_soc>;
 };
 
 &reg_soc {
+	regulator-allow-bypass;
 	vin-supply = <&vdd_soc>;
 };
 
@@ -186,6 +250,14 @@
 	status = "disabled";
 };
 
+&wdog1 {
+	/*
+	 * Rely on PMIC reboot handler. Internal i.MX6 watchdog, that is also
+	 * used for reboot, does not reset all external PMIC voltages on reset.
+	 */
+	status = "disabled";
+};
+
 &iomuxc {
 	pinctrl_enet: enetgrp {
 		fsl,pins = <
diff --git a/arch/arm/boot/dts/imx6qdl.dtsi b/arch/arm/boot/dts/imx6qdl.dtsi
index e9955ef12e02..a563e06aba23 100644
--- a/arch/arm/boot/dts/imx6qdl.dtsi
+++ b/arch/arm/boot/dts/imx6qdl.dtsi
@@ -294,7 +294,7 @@
 			status = "disabled";
 		};
 
-		aips-bus@2000000 { /* AIPS1 */
+		bus@2000000 { /* AIPS1 */
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -935,7 +935,7 @@
 			};
 		};
 
-		aips-bus@2100000 { /* AIPS2 */
+		bus@2100000 { /* AIPS2 */
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/boot/dts/imx6qp-phytec-mira-rdk-nand.dts b/arch/arm/boot/dts/imx6qp-phytec-mira-ff-rdk-nand.dts
similarity index 78%
rename from arch/arm/boot/dts/imx6qp-phytec-mira-rdk-nand.dts
rename to arch/arm/boot/dts/imx6qp-phytec-mira-ff-rdk-nand.dts
index f27d7ab42626..0b3b979ab55f 100644
--- a/arch/arm/boot/dts/imx6qp-phytec-mira-rdk-nand.dts
+++ b/arch/arm/boot/dts/imx6qp-phytec-mira-ff-rdk-nand.dts
@@ -8,9 +8,11 @@
 #include "imx6qp.dtsi"
 #include "imx6qdl-phytec-phycore-som.dtsi"
 #include "imx6qdl-phytec-mira.dtsi"
+#include "imx6qdl-phytec-mira-peb-eval-01.dtsi"
+#include "imx6qdl-phytec-mira-peb-av-02.dtsi"
 
 / {
-	model = "PHYTEC phyBOARD-Mira QuadPlus Carrier-Board with NAND";
+	model = "PHYTEC phyBOARD-Mira QuadPlus full featured with NAND";
 	compatible = "phytec,imx6qp-pbac06-nand", "phytec,imx6qp-pbac06",
 		     "phytec,imx6qdl-pcm058", "fsl,imx6qp";
 
@@ -23,6 +25,10 @@
 	status = "okay";
 };
 
+&dim_gpio_leds {
+	status = "okay";
+};
+
 &fec {
 	status = "okay";
 };
@@ -47,6 +53,10 @@
 	status = "okay";
 };
 
+&leddim {
+	status = "okay";
+};
+
 &m25p80 {
 	status = "okay";
 };
diff --git a/arch/arm/boot/dts/imx6qp.dtsi b/arch/arm/boot/dts/imx6qp.dtsi
index 3633383db706..4d23c92aa8a6 100644
--- a/arch/arm/boot/dts/imx6qp.dtsi
+++ b/arch/arm/boot/dts/imx6qp.dtsi
@@ -24,7 +24,7 @@
 			clocks = <&clks IMX6QDL_CLK_OCRAM>;
 		};
 
-		aips-bus@2100000 {
+		bus@2100000 {
 			pre1: pre@21c8000 {
 				compatible = "fsl,imx6qp-pre";
 				reg = <0x021c8000 0x1000>;
diff --git a/arch/arm/boot/dts/imx6sl.dtsi b/arch/arm/boot/dts/imx6sl.dtsi
index 852f66944c7d..37d73795f0ee 100644
--- a/arch/arm/boot/dts/imx6sl.dtsi
+++ b/arch/arm/boot/dts/imx6sl.dtsi
@@ -146,7 +146,7 @@
 			arm,data-latency = <4 2 3>;
 		};
 
-		aips1: aips-bus@2000000 {
+		aips1: bus@2000000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -789,7 +789,7 @@
 			};
 		};
 
-		aips2: aips-bus@2100000 {
+		aips2: bus@2100000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/boot/dts/imx6sll.dtsi b/arch/arm/boot/dts/imx6sll.dtsi
index 39500b84673b..1fbabaa7336b 100644
--- a/arch/arm/boot/dts/imx6sll.dtsi
+++ b/arch/arm/boot/dts/imx6sll.dtsi
@@ -147,7 +147,7 @@
 			arm,data-latency = <4 2 3>;
 		};
 
-		aips1: aips-bus@2000000 {
+		aips1: bus@2000000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -657,7 +657,7 @@
 			};
 		};
 
-		aips2: aips-bus@2100000 {
+		aips2: bus@2100000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/boot/dts/imx6sx.dtsi b/arch/arm/boot/dts/imx6sx.dtsi
index b3e24d8bd299..8dc71a0c3edc 100644
--- a/arch/arm/boot/dts/imx6sx.dtsi
+++ b/arch/arm/boot/dts/imx6sx.dtsi
@@ -241,7 +241,7 @@
 			status = "disabled";
 		};
 
-		aips1: aips-bus@2000000 {
+		aips1: bus@2000000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -836,7 +836,7 @@
 			};
 		};
 
-		aips2: aips-bus@2100000 {
+		aips2: bus@2100000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -1194,7 +1194,7 @@
 			};
 		};
 
-		aips3: aips-bus@2200000 {
+		aips3: bus@2200000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/boot/dts/imx6ul-phytec-peb-wlbt-01.dtsi b/arch/arm/boot/dts/imx6ul-phytec-peb-wlbt-01.dtsi
new file mode 100644
index 000000000000..998419535c77
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ul-phytec-peb-wlbt-01.dtsi
@@ -0,0 +1,66 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2017 PHYTEC Messtechnik GmbH
+ * Author: Stefan Riedmueller <s.riedmueller@phytec.de>
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	reg_wlan_en: regulator-wlan-en {
+		compatible = "regulator-fixed";
+		regulator-name = "wlan_en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio5 9 GPIO_ACTIVE_HIGH>;
+		startup-delay-us = <70000>; /* card specific delay */
+		enable-active-high;
+		status = "disabled";
+	};
+};
+
+&iomuxc {
+	pinctrl_usdhc2_wlan: usdhc2grp_wlan {
+		fsl,pins = <
+			MX6UL_PAD_LCD_DATA18__USDHC2_CMD	0x17059
+			MX6UL_PAD_LCD_DATA19__USDHC2_CLK	0x10059
+			MX6UL_PAD_LCD_DATA20__USDHC2_DATA0	0x17059
+			MX6UL_PAD_LCD_DATA21__USDHC2_DATA1	0x17059
+			MX6UL_PAD_LCD_DATA22__USDHC2_DATA2	0x17059
+			MX6UL_PAD_LCD_DATA23__USDHC2_DATA3	0x17059
+		>;
+	};
+
+	pinctrl_wlan: wlangrp {
+		fsl,pins = <
+			/* WLAN ENABLE */
+			MX6UL_PAD_SNVS_TAMPER9__GPIO5_IO09	0x80000000
+			/* WLAN IRQ */
+			MX6UL_PAD_GPIO1_IO03__GPIO1_IO03	0x80000000
+		>;
+	};
+};
+
+/* SDHC2 on phyBOARD-Segin i.MX6UL */
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_wlan &pinctrl_wlan>;
+	vmmc-supply = <&reg_wlan_en>;
+	bus-width = <4>;
+	non-removable;
+	cap-power-off-card;
+	keep-power-in-suspend;
+	status = "disabled";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	wlcore: wlcore@2 {
+		compatible = "ti,wl1271";
+		reg = <2>; /* WLAN function -> 2 */
+		interrupt-parent = <&gpio1>;
+		interrupts = <3 IRQ_TYPE_EDGE_RISING>;
+		ref-clock-frequency = <38400000>; /* Hz = 38.4 MHz */
+	};
+};
diff --git a/arch/arm/boot/dts/imx6ul-phytec-peb-wlbt-05.dtsi b/arch/arm/boot/dts/imx6ul-phytec-peb-wlbt-05.dtsi
new file mode 100644
index 000000000000..44597ed29aec
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ul-phytec-peb-wlbt-05.dtsi
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Author: Yunus Bas <y.bas@phytec.de>
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	reg_bt_en: regulator-bt-en {
+		compatible = "regulator-fixed";
+		regulator-name = "bt_en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio1 1 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	reg_wl_en: regulator-wl-en {
+		compatible = "regulator-fixed";
+		regulator-name = "wlan_en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio5 9 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+		enable-active-high;
+		regulator-always-on;
+	};
+};
+
+/* BLUETOOTH */
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2_bt &pinctrl_bt>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+/* WLAN */
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_wl &pinctrl_wl>;
+	vmmc-supply = <&reg_wl_en>;
+	bus-width = <4>;
+	non-removable;
+	no-1-8-v;
+	status = "disabled";
+};
+
+&iomuxc {
+	pinctrl_uart2_bt: uart2grp-bt {
+	fsl,pins = <
+			MX6UL_PAD_UART2_TX_DATA__UART2_DCE_TX	0x17059
+			MX6UL_PAD_UART2_RX_DATA__UART2_DCE_RX	0x17059
+			MX6UL_PAD_UART2_CTS_B__UART2_DCE_CTS	0x17059
+			MX6UL_PAD_UART2_RTS_B__UART2_DCE_RTS	0x17059
+		>;
+	};
+
+	pinctrl_usdhc2_wl: usdhc2grp-wl {
+		fsl,pins = <
+			MX6UL_PAD_LCD_DATA18__USDHC2_CMD	0x10051
+			MX6UL_PAD_LCD_DATA19__USDHC2_CLK	0x10061
+			MX6UL_PAD_LCD_DATA20__USDHC2_DATA0	0x10051
+			MX6UL_PAD_LCD_DATA21__USDHC2_DATA1	0x10051
+			MX6UL_PAD_LCD_DATA22__USDHC2_DATA2	0x10051
+			MX6UL_PAD_LCD_DATA23__USDHC2_DATA3	0x10051
+		>;
+	};
+
+	pinctrl_bt: btgrp {
+		fsl,pins = <
+			/* BT ENABLE */
+			MX6UL_PAD_GPIO1_IO01__GPIO1_IO01	0x3031
+		>;
+	};
+
+	pinctrl_wl: wlgrp {
+		fsl,pins = <
+			/* WLAN ENABLE */
+			MX6UL_PAD_SNVS_TAMPER9__GPIO5_IO09	0x3031
+		>;
+	};
+};
diff --git a/arch/arm/boot/dts/imx6ul-phytec-phycore-som.dtsi b/arch/arm/boot/dts/imx6ul-phytec-phycore-som.dtsi
index 41f3b7f62bbf..6d4a0348b9e6 100644
--- a/arch/arm/boot/dts/imx6ul-phytec-phycore-som.dtsi
+++ b/arch/arm/boot/dts/imx6ul-phytec-phycore-som.dtsi
@@ -35,6 +35,32 @@
 			linux,default-trigger = "heartbeat";
 		};
 	};
+
+	reg_gpio_dvfs: regulator-gpio {
+		compatible = "regulator-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_dvfs>;
+		regulator-min-microvolt = <1300000>;
+		regulator-max-microvolt = <1400000>;
+		regulator-ramp-delay = <500>;
+		regulator-name = "gpio_dvfs";
+		regulator-type = "voltage";
+		gpios = <&gpio4 14 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0>;
+		states = <1300000 0x1 1400000 0x0>;
+		enable-at-boot;
+	};
+};
+
+&cpu0 {
+	dc-supply = <&reg_gpio_dvfs>;
+	fsl,soc-operating-points = <
+		/* KHz	uV */
+		696000	1275000
+		528000	1250000
+		396000	1250000
+		198000	1250000
+	>;
 };
 
 &fec1 {
@@ -75,6 +101,7 @@
 
 	eeprom@52 {
 		compatible = "catalyst,24c32", "atmel,24c32";
+		pagesize = <32>;
 		reg = <0x52>;
 	};
 };
@@ -99,6 +126,12 @@
 };
 
 &iomuxc {
+	pinctrl_dvfs: dvfsgrp {
+		fsl,pins = <
+			MX6UL_PAD_NAND_CE1_B__GPIO4_IO14	0x79
+		>;
+	};
+
 	pinctrl_enet1: enet1grp {
 		fsl,pins = <
 			MX6UL_PAD_GPIO1_IO07__ENET1_MDC		0x10010
diff --git a/arch/arm/boot/dts/imx6ul-phytec-segin-ff-rdk-emmc.dts b/arch/arm/boot/dts/imx6ul-phytec-segin-ff-rdk-emmc.dts
new file mode 100644
index 000000000000..af8b35dde274
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ul-phytec-segin-ff-rdk-emmc.dts
@@ -0,0 +1,94 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Author: Yunus Bas <y.bas@phytec.de>
+ */
+
+/dts-v1/;
+#include "imx6ul.dtsi"
+#include "imx6ul-phytec-phycore-som.dtsi"
+#include "imx6ul-phytec-segin.dtsi"
+#include "imx6ul-phytec-segin-peb-av-02.dtsi"
+#include "imx6ul-phytec-segin-peb-eval-01.dtsi"
+
+/ {
+	model = "PHYTEC phyBOARD-Segin i.MX6 UltraLite Full Featured with eMMC";
+	compatible = "phytec,imx6ul-pbacd10-emmc", "phytec,imx6ul-pbacd10",
+		     "phytec,imx6ul-pcl063", "fsl,imx6ul";
+};
+
+&adc1 {
+	status = "okay";
+};
+
+&can1 {
+	status = "okay";
+};
+
+&tlv320 {
+	status = "okay";
+};
+
+&ecspi3 {
+	status = "okay";
+};
+
+&ethphy1 {
+	status = "okay";
+};
+
+&ethphy2 {
+	status = "okay";
+};
+
+&fec1 {
+	status = "okay";
+};
+
+&fec2 {
+	status = "okay";
+};
+
+&i2c_rtc {
+	status = "okay";
+};
+
+&reg_can1_en {
+	status = "okay";
+};
+
+&reg_sound_1v8 {
+	status = "okay";
+};
+
+&reg_sound_3v3 {
+	status = "okay";
+};
+
+&sai2 {
+	status = "okay";
+};
+
+&sound {
+	status = "okay";
+};
+
+&uart5 {
+	status = "okay";
+};
+
+&usbotg1 {
+	status = "okay";
+};
+
+&usbotg2 {
+	status = "okay";
+};
+
+&usdhc1 {
+	status = "okay";
+};
+
+&usdhc2 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/imx6ul-phytec-segin-ff-rdk-nand-rs485.dts b/arch/arm/boot/dts/imx6ul-phytec-segin-ff-rdk-nand-rs485.dts
new file mode 100644
index 000000000000..9548ac49dc56
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ul-phytec-segin-ff-rdk-nand-rs485.dts
@@ -0,0 +1,109 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2017 PHYTEC Messtechnik GmbH
+ * Author: Stefan Riedmller <s.riedmueller@phytec.de>
+ */
+
+/dts-v1/;
+#include "imx6ul.dtsi"
+#include "imx6ul-phytec-phycore-som.dtsi"
+#include "imx6ul-phytec-segin.dtsi"
+#include "imx6ul-phytec-segin-peb-av-02.dtsi"
+#include "imx6ul-phytec-segin-peb-eval-01.dtsi"
+#include "imx6ul-phytec-peb-wlbt-01.dtsi"
+#include "imx6ul-phytec-peb-wlbt-05.dtsi"
+
+/ {
+	model = "PHYTEC phyBOARD-Segin i.MX6 UltraLight full-featured with NAND and RS485";
+	compatible = "phytec,imx6ul-pbacd10i-nand", "phytec,imx6ul-pbacd10",
+		     "phytec,imx6ul-pcl063", "fsl,imx6ul";
+};
+
+&adc1 {
+	status = "okay";
+};
+
+&can1 {
+	status = "okay";
+};
+
+&tlv320 {
+	status = "okay";
+};
+
+&ecspi3 {
+	status = "okay";
+};
+
+&ethphy1 {
+	status = "okay";
+};
+
+&ethphy2 {
+	status = "okay";
+};
+
+&fec1 {
+	status = "okay";
+};
+
+&fec2 {
+	status = "okay";
+};
+
+&gpmi {
+	status = "okay";
+};
+
+&i2c_rtc {
+	status = "okay";
+};
+
+&reg_can1_en {
+	status = "okay";
+};
+
+&reg_sound_1v8 {
+	status = "okay";
+};
+
+&reg_sound_3v3 {
+	status = "okay";
+};
+
+&sai2 {
+	status = "okay";
+};
+
+&sound {
+	status = "okay";
+};
+
+&uart5 {
+	rts-gpios = <&gpio1 9 GPIO_ACTIVE_HIGH>;
+	rs485-rts-active-high;
+	linux,rs485-enabled-at-boot-time;
+	status = "okay";
+};
+
+&usbotg1 {
+	status = "okay";
+};
+
+&usbotg2 {
+	status = "okay";
+};
+
+&usdhc1 {
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl_uart5: uart5grp {
+		fsl,pins = <
+			MX6UL_PAD_UART5_TX_DATA__UART5_DCE_TX	0x1b0b1
+			MX6UL_PAD_UART5_RX_DATA__UART5_DCE_RX	0x1b0b1
+			MX6UL_PAD_GPIO1_IO09__GPIO1_IO09	0x1a0b1
+		>;
+	};
+};
diff --git a/arch/arm/boot/dts/imx6ul-phytec-segin-ff-rdk-nand.dts b/arch/arm/boot/dts/imx6ul-phytec-segin-ff-rdk-nand.dts
index 699dfcbf9a60..5ae6e2a696c5 100644
--- a/arch/arm/boot/dts/imx6ul-phytec-segin-ff-rdk-nand.dts
+++ b/arch/arm/boot/dts/imx6ul-phytec-segin-ff-rdk-nand.dts
@@ -8,7 +8,10 @@
 #include "imx6ul.dtsi"
 #include "imx6ul-phytec-phycore-som.dtsi"
 #include "imx6ul-phytec-segin.dtsi"
+#include "imx6ul-phytec-segin-peb-av-02.dtsi"
 #include "imx6ul-phytec-segin-peb-eval-01.dtsi"
+#include "imx6ul-phytec-peb-wlbt-01.dtsi"
+#include "imx6ul-phytec-peb-wlbt-05.dtsi"
 
 / {
 	model = "PHYTEC phyBOARD-Segin i.MX6 UltraLite Full Featured with NAND";
diff --git a/arch/arm/boot/dts/imx6ul-phytec-segin-peb-av-02.dtsi b/arch/arm/boot/dts/imx6ul-phytec-segin-peb-av-02.dtsi
new file mode 100644
index 000000000000..375c41c01de0
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ul-phytec-segin-peb-av-02.dtsi
@@ -0,0 +1,106 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2016 PHYTEC Messtechnik
+ * Author: Christian Hemp <c.hemp@phytec.de>
+ */
+
+/ {
+	panel-lcd {
+		compatible = "edt,etm0700g0edh6";
+		backlight = <&backlight_peb>;
+		status = "disabled";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&display_out>;
+			};
+		};
+	};
+
+	backlight_peb: backlight {
+		compatible = "pwm-backlight";
+		brightness-levels = < 0  4 8 16 32 64 128 255>;
+		default-brightness-level = <5>;
+		power-supply = <&reg_backlight_en>;
+		pwms = <&pwm3 0 5000000>;
+		status = "disabled";
+	};
+
+	reg_backlight_en: regulator-backlight-en {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_backlight_en>;
+		regulator-name = "Backlight";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio1 18 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		status = "disabled";
+	};
+};
+
+&lcdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lcdif_dat>;
+	status = "disabled";
+
+	port {
+		display_out: endpoint {
+			remote-endpoint = <&panel_in>;
+		};
+	};
+};
+
+&i2c1 {
+	polytouch: edt-ft5x06@38 {
+		compatible = "edt,edt-ft5x06";
+		reg = <0x38>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_edt_ft5x06>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
+		wakeup-source;
+		status = "disabled";
+	};
+};
+
+&iomuxc {
+	pinctrl_edt_ft5x06: edtft5x06grp {
+		fsl,pins = <
+			MX6UL_PAD_SNVS_TAMPER5__GPIO5_IO05	0x1b0b0
+		>;
+	};
+
+	pinctrl_backlight_en: backlightengrp {
+		fsl,pins = <
+			MX6UL_PAD_UART1_CTS_B__GPIO1_IO18	0x1b0b0
+		>;
+	};
+
+	pinctrl_lcdif_dat: lcdifdatgrp {
+		fsl,pins = <
+			MX6UL_PAD_LCD_DATA00__LCDIF_DATA00  0x59
+			MX6UL_PAD_LCD_DATA01__LCDIF_DATA01  0x59
+			MX6UL_PAD_LCD_DATA02__LCDIF_DATA02  0x59
+			MX6UL_PAD_LCD_DATA03__LCDIF_DATA03  0x59
+			MX6UL_PAD_LCD_DATA04__LCDIF_DATA04  0x59
+			MX6UL_PAD_LCD_DATA05__LCDIF_DATA05  0x59
+			MX6UL_PAD_LCD_DATA06__LCDIF_DATA06  0x59
+			MX6UL_PAD_LCD_DATA07__LCDIF_DATA07  0x59
+			MX6UL_PAD_LCD_DATA08__LCDIF_DATA08  0x59
+			MX6UL_PAD_LCD_DATA09__LCDIF_DATA09  0x59
+			MX6UL_PAD_LCD_DATA10__LCDIF_DATA10  0x59
+			MX6UL_PAD_LCD_DATA11__LCDIF_DATA11  0x59
+			MX6UL_PAD_LCD_DATA12__LCDIF_DATA12  0x59
+			MX6UL_PAD_LCD_DATA13__LCDIF_DATA13  0x59
+			MX6UL_PAD_LCD_DATA14__LCDIF_DATA14  0x59
+			MX6UL_PAD_LCD_DATA15__LCDIF_DATA15  0x59
+			MX6UL_PAD_LCD_DATA16__LCDIF_DATA16  0x59
+			MX6UL_PAD_LCD_DATA17__LCDIF_DATA17  0x59
+			MX6UL_PAD_LCD_CLK__LCDIF_CLK	    0x59
+			MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE  0x59
+			MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC    0x59
+			MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC    0x59
+		>;
+	};
+};
diff --git a/arch/arm/boot/dts/imx6ul-phytec-segin.dtsi b/arch/arm/boot/dts/imx6ul-phytec-segin.dtsi
index 8d5f8dc6ad58..c2738056b06e 100644
--- a/arch/arm/boot/dts/imx6ul-phytec-segin.dtsi
+++ b/arch/arm/boot/dts/imx6ul-phytec-segin.dtsi
@@ -106,8 +106,18 @@
 &ecspi3 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_ecspi3>;
-	cs-gpios = <&gpio1 20 GPIO_ACTIVE_HIGH>;
+	cs-gpios = <&gpio1 20 GPIO_ACTIVE_LOW>;
+	dmas = <&sdma 7 8 0>,
+	       <&sdma 8 8 0>;
+	dma-names = "rx", "tx";
 	status = "disabled";
+
+	spi_dev0: spi@0 {
+		compatible = "spidev";
+		spi-max-frequency = <57600000>;
+		reg = <0>;
+		status = "disabled";
+	};
 };
 
 &fec2 {
@@ -139,7 +149,7 @@
 		pinctrl-0 = <&pinctrl_stmpe>;
 		status = "disabled";
 
-		touchscreen {
+		stmpe_touchscreen {
 			compatible = "st,stmpe-ts";
 			st,sample-time = <4>;
 			st,mod-12b = <1>;
@@ -204,6 +214,7 @@
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_usb_otg1_id>;
 	dr_mode = "otg";
+	disable-over-current;
 	status = "disabled";
 };
 
@@ -234,9 +245,9 @@
 
 	pinctrl_ecspi3: ecspi3grp {
 		fsl,pins = <
-			MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO	0x10b0
-			MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI	0x10b0
-			MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK	0x10b0
+			MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK	0x100b1
+			MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO	0x100b1
+			MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI	0x100b1
 			MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20	0x10b0
 		>;
 	};
diff --git a/arch/arm/boot/dts/imx6ul.dtsi b/arch/arm/boot/dts/imx6ul.dtsi
index ae0722b93b9d..fe8a9e100783 100644
--- a/arch/arm/boot/dts/imx6ul.dtsi
+++ b/arch/arm/boot/dts/imx6ul.dtsi
@@ -205,7 +205,7 @@
 			status = "disabled";
 		};
 
-		aips1: aips-bus@2000000 {
+		aips1: bus@2000000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -771,7 +771,7 @@
 			};
 		};
 
-		aips2: aips-bus@2100000 {
+		aips2: bus@2100000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/boot/dts/imx6ull-phytec-consolinno-basemodule.dts b/arch/arm/boot/dts/imx6ull-phytec-consolinno-basemodule.dts
new file mode 100644
index 000000000000..0299a1570f5b
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ull-phytec-consolinno-basemodule.dts
@@ -0,0 +1,344 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2019 PHYTEC Messtechnik GmbH
+ * Author: Stefan Riedmueller <s.riedmueller@phytec.de>
+ * Author: Simon Stuerz <simon.stuerz@nymea.io>
+ * Author: Paul Budich <p.budich@consolinno.de>
+ * Author: Alexander Pietsch <a.pietsch@consolinno.de>
+ * Author: Leonid Verhovskij <l.verhovskij@consolinno.de>
+ */
+
+/dts-v1/;
+#include "imx6ull.dtsi"
+#include "imx6ull-phytec-phycore-som.dtsi"
+#include "imx6ull-phytec-segin.dtsi"
+#include "imx6ull-phytec-segin-peb-av-02.dtsi"
+#include "imx6ull-phytec-segin-peb-eval-01.dtsi"
+
+/ {
+	model = "PHYTEC phyBOARD-Segin i.MX6 ULL Full Featured with eMMC";
+	compatible = "phytec,imx6ull-pbacd10-emmc", "phytec,imx6ull-pbacd10",
+		     "phytec,imx6ull-pcl063","fsl,imx6ull";
+
+	aliases {
+		mmc0 = &usdhc1; /* uSD / MMC  */
+		mmc1 = &usdhc2; /* internal eMMC */
+		ethernet2 ="/soc/bus@2100000/usb@2184200/ethernet@1/";
+	};
+};
+
+&snvs_poweroff {
+   status = "okay";
+};
+
+&adc1 {
+	status = "okay";
+};
+
+&can1 {
+	status = "okay";
+};
+
+&ecspi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1>;
+	cs-gpios = <&gpio4 26 GPIO_ACTIVE_LOW>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+	tpm0: slb9670@0 {
+		pinctrl-names = "default";
+		compatible = "infineon,slb9670", "tcg,tpm_tis-spi";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		spi-max-frequency = <32000000>;
+		reg = <0>; //cs0
+		status = "okay";
+	};
+};
+
+&ethphy1 {
+	status = "okay";
+};
+
+&ethphy2 {
+	interrupt-parent = <&gpio4>;
+	interrupts = <16 IRQ_TYPE_LEVEL_LOW>;
+	status = "okay";
+};
+
+&fec1 {
+	status = "okay";
+};
+
+&fec2 {
+	status = "okay";
+};
+
+&snvs_rtc {
+	status = "disabled";
+};
+
+&i2c_rtc {
+
+	pinctrl-0 = <&pinctrl_rtc_1>;
+	interrupt-parent = <&gpio1>;
+	interrupts = <31 IRQ_TYPE_LEVEL_LOW>;
+	status = "okay";
+	
+};
+
+
+&reg_can1_en {
+	status = "okay";
+};
+
+
+/* DEBUG Port */
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	uart-has-rtscts;
+	status = "okay";
+};
+
+/* Zigbee/Bluetooth */
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	uart-has-rtscts;
+	status = "okay";
+};
+
+/* RS232 on 16pin output header */
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};
+
+/* RS485-2 on RJ45 */
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	status = "okay";
+};
+
+/* wMbus */
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5>;
+	status = "okay";
+};
+
+/* wMbRS485-1 on 16pin output header */
+&uart6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart6>;
+	status = "okay";
+};
+
+
+
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	bus-width = <8>;
+	no-1-8-v;
+	non-removable;
+	keep-power-in-suspend;
+	status = "okay";
+};
+
+&i2c1 {
+
+	eepromnfc@53 {
+		compatible = "st25dv,st25dv04k";
+		reg = <0x53>;
+		status = "disabled";
+	};
+
+	conegx@48 {
+		pinctrl-0 = <&pinctrl_msp>;
+		compatible = "consolinno,conegx";
+		reg = <0x48>; /* I2C Adress */
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		/*
+		pinctrl-names = "default";
+		pinctrl-0 = <&conegx_pins>;
+		*/
+		
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		
+		interrupt-parent = <&gpio3>;
+		interrupts = <3 0x1>; // Pin Type(1=Rising)
+		
+	};
+
+
+
+};
+
+
+&can1 {                                                                           
+        pinctrl-names = "default";                                                
+        pinctrl-0 = <&pinctrl_flexcan1>;                                          
+		status = "okay";                                                      
+};
+
+&usbotg1 {                                                                       
+        pinctrl-names = "default";                                               
+        pinctrl-0 = <&pinctrl_usb_otg1_id>;                                      
+        dr_mode = "otg";                                                         
+        status = "okay";                                                     
+};  
+
+&usbotg2 {                  
+		pinctrl-names = "default";                                               
+        pinctrl-0 = <&pinctrl_usb_otg2_id>;                                                  
+        dr_mode = "host";                                                        
+        disable-over-current;                                                    
+        status = "okay";        
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+		smsc95xx1: ethernet@1 {
+			compatible = "usb424,9e00";
+			reg = <1>;
+			local-mac-address = [00 00 00 00 00 00];
+		};                                            
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+ 
+ 
+	pinctrl_hog: hoggrp {
+		fsl,pins = <
+			MX6UL_PAD_CSI_VSYNC__GPIO4_IO19		0x10b0
+			MX6UL_PAD_CSI_HSYNC__GPIO4_IO20		0x10b0 
+			MX6UL_PAD_SD1_CLK__GPIO2_IO17		0x10b0
+			MX6UL_PAD_SD1_CMD__GPIO2_IO16		0x10b0
+			MX6UL_PAD_SD1_DATA2__GPIO2_IO20		0x10b0
+			MX6UL_PAD_LCD_VSYNC__GPIO3_IO03		0x10b0
+			MX6UL_PAD_LCD_RESET__GPIO3_IO04		0x10b0
+			MX6UL_PAD_LCD_HSYNC__GPIO3_IO02		0x10b0
+			MX6UL_PAD_UART5_TX_DATA__GPIO1_IO30		0x10b0
+		>;
+	};
+
+	pinctrl_msp: mspgrp {
+		fsl,pins = <
+			MX6UL_PAD_LCD_VSYNC__GPIO3_IO03	0x110a0
+		>;
+	};
+	
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX	0x1b0b1
+			MX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX	0x1b0b1
+			MX6ULL_PAD_UART1_CTS_B__UART5_DCE_CTS	0x1b0b1
+			MX6ULL_PAD_UART1_RTS_B__UART5_DCE_RTS	0x1b0b1
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX6UL_PAD_UART2_TX_DATA__UART2_DCE_TX	0x1b0b1
+			MX6UL_PAD_UART2_RX_DATA__UART2_DCE_RX	0x1b0b1
+			MX6UL_PAD_UART2_CTS_B__UART2_DCE_CTS	0x1b0b1
+			MX6UL_PAD_UART2_RTS_B__UART2_DCE_RTS	0x1b0b1
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			MX6UL_PAD_UART3_TX_DATA__UART3_DCE_TX	0x1b0b1
+			MX6UL_PAD_UART3_RX_DATA__UART3_DCE_RX	0x1b0b1
+		>;
+	};
+
+	pinctrl_uart4: uart4grp {
+		fsl,pins = <
+			MX6UL_PAD_LCD_ENABLE__UART4_DCE_RX		0x1b0b1
+			MX6UL_PAD_LCD_CLK__UART4_DCE_TX			0x1b0b1
+		>;
+	};
+
+	pinctrl_uart5: uart5grp {
+		fsl,pins = <
+			MX6UL_PAD_GPIO1_IO04__UART5_DCE_TX		0x1b0b1
+			MX6UL_PAD_GPIO1_IO05__UART5_DCE_RX		0x1b0b1
+		>;
+	};
+
+	pinctrl_uart6: uart6grp {
+		fsl,pins = <
+			MX6UL_PAD_CSI_PIXCLK__UART6_DCE_RX		0x1b0b1
+			MX6UL_PAD_CSI_MCLK__UART6_DCE_TX		0x1b0b1
+		>;
+	};
+
+	pinctrl_ecspi1: ecspi1-grp {
+		fsl,pins = <
+			MX6UL_PAD_CSI_DATA07__ECSPI1_MISO	0x100b1
+			MX6UL_PAD_CSI_DATA06__ECSPI1_MOSI	0x100b1
+			MX6UL_PAD_CSI_DATA04__ECSPI1_SCLK	0x100b1
+			MX6UL_PAD_CSI_DATA05__GPIO4_IO26	0x1b0b0 	/* SS0 */
+		>;
+	};
+
+	
+
+	pinctrl_ecspi1_tpm: ecspi1-tpm-grp {
+		fsl,pins = <
+			MX6UL_PAD_CSI_DATA00__GPIO4_IO21	0x1b0b0 /* irq */
+			MX6UL_PAD_UART3_CTS_B__GPIO1_IO26	0x1b0b0 /* reset */
+		>;
+	};
+
+
+	pinctrl_flexcan1: flexcan1 {                                             
+		fsl,pins = <                                                     
+			MX6UL_PAD_SD1_DATA0__FLEXCAN1_TX     0x0b0b0          
+			MX6UL_PAD_SD1_DATA1__FLEXCAN1_RX     0x0b0b0          
+		>;                                                               
+        }; 
+ 
+	pinctrl_usb_otg1_id: usbotg1idgrp {                                      
+			fsl,pins = <                                                     
+					MX6UL_PAD_GPIO1_IO00__ANATOP_OTG1_ID    0x17059          
+			>;                                                               
+	};
+	pinctrl_usb_otg2_id: usbotg2idgrp {
+		fsl,pins = <
+			MX6UL_PAD_SD1_DATA3__ANATOP_OTG2_ID	0x17059
+		>;
+	};
+
+	pinctrl_enet2: enet2grp {
+		fsl,pins = <
+			MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN	0x1b0b0
+			MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER	0x1b0b0
+			MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00	0x1b0b0
+			MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01	0x1b0b0
+			MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN	0x1b010
+			MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00	0x1b010
+			MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01	0x1b010
+			MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2	0x4001b010
+			/* INT# */
+			MX6UL_PAD_NAND_DQS__GPIO4_IO16		0x1b0b0
+		>;
+	};
+
+	pinctrl_rtc_1: rtc1intgrp {
+		fsl,pins = <
+			MX6UL_PAD_UART5_RX_DATA__GPIO1_IO31 0x000010B0
+		>;
+	};
+};
diff --git a/arch/arm/boot/dts/imx6ull-phytec-peb-wlbt-01.dtsi b/arch/arm/boot/dts/imx6ull-phytec-peb-wlbt-01.dtsi
new file mode 100644
index 000000000000..d3bd65ef134c
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ull-phytec-peb-wlbt-01.dtsi
@@ -0,0 +1,28 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2018 PHYTEC Messtechnik GmbH
+ * Author: Stefan Riedmueller <s.riedmueller@phytec.de>
+ */
+
+#include "imx6ul-phytec-peb-wlbt-01.dtsi"
+
+&pinctrl_wlan {
+	fsl,pins = <
+		MX6UL_PAD_GPIO1_IO03__GPIO1_IO03        0x10b0
+	>;
+};
+
+&iomuxc_snvs {
+	pinctrl_snvswlan: snvswlangrp {
+		fsl,pins = <
+			MX6ULL_PAD_SNVS_TAMPER9__GPIO5_IO09	0x110a0
+		>;
+	};
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_wlan
+		     &pinctrl_wlan
+		     &pinctrl_snvswlan>;
+};
diff --git a/arch/arm/boot/dts/imx6ull-phytec-peb-wlbt-05.dtsi b/arch/arm/boot/dts/imx6ull-phytec-peb-wlbt-05.dtsi
new file mode 100644
index 000000000000..a901b11c2f64
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ull-phytec-peb-wlbt-05.dtsi
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2020 PHYTEC Messtechnik GmbH
+ * Author: Yunus Bas <y.bas@phytec.de>
+ */
+
+#include "imx6ul-phytec-peb-wlbt-05.dtsi"
+
+&iomuxc_snvs {
+	pinctrl_snvs_wl: snvswlgrp {
+		fsl,pins = <
+			MX6ULL_PAD_SNVS_TAMPER9__GPIO5_IO09	0x3031
+		>;
+	};
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_wl &pinctrl_snvs_wl>;
+};
diff --git a/arch/arm/boot/dts/imx6ull-phytec-phycore-som.dtsi b/arch/arm/boot/dts/imx6ull-phytec-phycore-som.dtsi
index 56cd16e5a77f..80da74ace903 100644
--- a/arch/arm/boot/dts/imx6ull-phytec-phycore-som.dtsi
+++ b/arch/arm/boot/dts/imx6ull-phytec-phycore-som.dtsi
@@ -11,6 +11,17 @@
 	compatible = "phytec,imx6ull-pcl063", "fsl,imx6ull";
 };
 
+&cpu0 {
+	fsl,soc-operating-points = <
+		/* KHz	uV */
+		900000	1250000
+		792000	1250000
+		528000	1250000
+		396000	1250000
+		198000	1250000
+	>;
+};
+
 &iomuxc {
 	/delete-node/ gpioledssomgrp;
 };
diff --git a/arch/arm/boot/dts/imx6ull-phytec-segin-ff-rdk-emmc.dts b/arch/arm/boot/dts/imx6ull-phytec-segin-ff-rdk-emmc.dts
index 9648d4ecaf58..adc6a0e8e88c 100644
--- a/arch/arm/boot/dts/imx6ull-phytec-segin-ff-rdk-emmc.dts
+++ b/arch/arm/boot/dts/imx6ull-phytec-segin-ff-rdk-emmc.dts
@@ -8,6 +8,7 @@
 #include "imx6ull.dtsi"
 #include "imx6ull-phytec-phycore-som.dtsi"
 #include "imx6ull-phytec-segin.dtsi"
+#include "imx6ull-phytec-segin-peb-av-02.dtsi"
 #include "imx6ull-phytec-segin-peb-eval-01.dtsi"
 
 / {
diff --git a/arch/arm/boot/dts/imx6ull-phytec-segin-ff-rdk-nand.dts b/arch/arm/boot/dts/imx6ull-phytec-segin-ff-rdk-nand.dts
index 656baf846453..9dcd84dbe894 100644
--- a/arch/arm/boot/dts/imx6ull-phytec-segin-ff-rdk-nand.dts
+++ b/arch/arm/boot/dts/imx6ull-phytec-segin-ff-rdk-nand.dts
@@ -8,7 +8,10 @@
 #include "imx6ull.dtsi"
 #include "imx6ull-phytec-phycore-som.dtsi"
 #include "imx6ull-phytec-segin.dtsi"
+#include "imx6ull-phytec-segin-peb-av-02.dtsi"
 #include "imx6ull-phytec-segin-peb-eval-01.dtsi"
+#include "imx6ull-phytec-peb-wlbt-01.dtsi"
+#include "imx6ull-phytec-peb-wlbt-05.dtsi"
 
 / {
 	model = "PHYTEC phyBOARD-Segin i.MX6 ULL Full Featured with NAND";
diff --git a/arch/arm/boot/dts/imx6ull-phytec-segin-peb-av-02.dtsi b/arch/arm/boot/dts/imx6ull-phytec-segin-peb-av-02.dtsi
new file mode 100644
index 000000000000..980a703320f3
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ull-phytec-segin-peb-av-02.dtsi
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2018 PHYTEC Messtechnik GmbH
+ * Author: Stefan Riedmueller <s.riedmueller@phytec.de>
+ */
+
+#include "imx6ul-phytec-segin-peb-av-02.dtsi"
+
+&iomuxc {
+	/delete-node/ edtft5x06grp;
+};
+
+&iomuxc_snvs {
+	pinctrl_edt_ft5x06: edtft5x06grp {
+		fsl,pins = <
+			MX6ULL_PAD_SNVS_TAMPER5__GPIO5_IO05	0x1b0b0
+		>;
+	};
+};
diff --git a/arch/arm/boot/dts/imx6ull.dtsi b/arch/arm/boot/dts/imx6ull.dtsi
index b7e67d121322..fcde7f77ae42 100644
--- a/arch/arm/boot/dts/imx6ull.dtsi
+++ b/arch/arm/boot/dts/imx6ull.dtsi
@@ -51,7 +51,7 @@
 
 / {
 	soc {
-		aips3: aips-bus@2200000 {
+		aips3: bus@2200000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/boot/dts/imx7s.dtsi b/arch/arm/boot/dts/imx7s.dtsi
index e2e604d6ba0b..e6b05dcbc090 100644
--- a/arch/arm/boot/dts/imx7s.dtsi
+++ b/arch/arm/boot/dts/imx7s.dtsi
@@ -316,7 +316,7 @@
 			      <0x31006000 0x2000>;
 		};
 
-		aips1: aips-bus@30000000 {
+		aips1: bus@30000000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -662,7 +662,7 @@
 			};
 		};
 
-		aips2: aips-bus@30400000 {
+		aips2: bus@30400000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -802,7 +802,7 @@
 			};
 		};
 
-		aips3: aips-bus@30800000 {
+		aips3: bus@30800000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/boot/dts/vf500.dtsi b/arch/arm/boot/dts/vf500.dtsi
index b0ec475017ad..0c0dd442300a 100644
--- a/arch/arm/boot/dts/vf500.dtsi
+++ b/arch/arm/boot/dts/vf500.dtsi
@@ -23,7 +23,7 @@
 	};
 
 	soc {
-		aips-bus@40000000 {
+		bus@40000000 {
 
 			intc: interrupt-controller@40003000 {
 				compatible = "arm,cortex-a9-gic";
@@ -43,7 +43,7 @@
 			};
 		};
 
-		aips-bus@40080000 {
+		bus@40080000 {
 			pmu@40089000 {
 				compatible = "arm,cortex-a5-pmu";
 				interrupts = <7 IRQ_TYPE_LEVEL_HIGH>;
diff --git a/arch/arm/boot/dts/vfxxx.dtsi b/arch/arm/boot/dts/vfxxx.dtsi
index fa248066d9d9..8a14ac34d131 100644
--- a/arch/arm/boot/dts/vfxxx.dtsi
+++ b/arch/arm/boot/dts/vfxxx.dtsi
@@ -59,7 +59,7 @@
 		interrupt-parent = <&mscm_ir>;
 		ranges;
 
-		aips0: aips-bus@40000000 {
+		aips0: bus@40000000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -471,7 +471,7 @@
 			};
 		};
 
-		aips1: aips-bus@40080000 {
+		aips1: bus@40080000 {
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/arm/configs/imx6_phytec_distro.config b/arch/arm/configs/imx6_phytec_distro.config
new file mode 100644
index 000000000000..0a05de7b4c8c
--- /dev/null
+++ b/arch/arm/configs/imx6_phytec_distro.config
@@ -0,0 +1,12 @@
+# CONFIG_INPUT_EVBUG is not set
+CONFIG_SQUASHFS=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
diff --git a/arch/arm/configs/imx6_phytec_machine.config b/arch/arm/configs/imx6_phytec_machine.config
new file mode 100644
index 000000000000..5b553e259b2c
--- /dev/null
+++ b/arch/arm/configs/imx6_phytec_machine.config
@@ -0,0 +1,5 @@
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_PROVE_LOCKING is not set
+CONFIG_STACKTRACE=y
+CONFIG_CMA_SIZE_MBYTES=256
+CONFIG_VLAN_8021Q=y
diff --git a/arch/arm/configs/imx6_phytec_platform.config b/arch/arm/configs/imx6_phytec_platform.config
new file mode 100644
index 000000000000..d4ed537528c7
--- /dev/null
+++ b/arch/arm/configs/imx6_phytec_platform.config
@@ -0,0 +1,10 @@
+CONFIG_CFG80211=m
+CONFIG_DA9063_WATCHDOG=y
+CONFIG_LEDS_PCA9532=y
+CONFIG_LEDS_PCA9532_GPIO=y
+CONFIG_LEDS_TRIGGER_MTD=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_R8169=m
+CONFIG_SPI_SPIDEV=y
+CONFIG_MAX1363=y
+CONFIG_HIDRAW=y
diff --git a/arch/arm/configs/imx6ull_consolinno_basemodule_defconfig b/arch/arm/configs/imx6ull_consolinno_basemodule_defconfig
new file mode 100644
index 000000000000..f5d1f302c1d4
--- /dev/null
+++ b/arch/arm/configs/imx6ull_consolinno_basemodule_defconfig
@@ -0,0 +1,632 @@
+CONFIG_LOCALVERSION="-consolinno-1u0022"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_KERNEL_LZO=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+CONFIG_MEMCG=y
+CONFIG_MEMCG_SWAP=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EXPERT=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_PERF_EVENTS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_ARCH_MULTI_V6=y
+CONFIG_ARCH_MXC=y
+# CONFIG_MACH_MX31ADS is not set
+# CONFIG_MACH_BUG is not set
+CONFIG_SOC_IMX6UL=y
+CONFIG_SOC_IMX7D=y
+CONFIG_SOC_IMX7ULP=y
+CONFIG_SOC_VF610=y
+CONFIG_ARM_ERRATA_764369=y
+CONFIG_SMP=y
+CONFIG_ARM_PSCI=y
+CONFIG_HIGHMEM=y
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_SECCOMP=y
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200"
+CONFIG_KEXEC=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_ARM_IMX6Q_CPUFREQ=y
+CONFIG_ARM_IMX_CPUFREQ_DT=y
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_BLK_DEV_THROTTLING=y
+CONFIG_BINFMT_MISC=m
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_INET_ESP=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_TABLES=y
+CONFIG_NF_TABLES_SET=y
+CONFIG_NF_TABLES_INET=y
+CONFIG_NF_TABLES_NETDEV=y
+CONFIG_NFT_NUMGEN=y
+CONFIG_NFT_CT=m
+CONFIG_NFT_COUNTER=m
+CONFIG_NFT_CONNLIMIT=m
+CONFIG_NFT_LOG=m
+CONFIG_NFT_LIMIT=m
+CONFIG_NFT_MASQ=m
+CONFIG_NFT_REDIR=m
+CONFIG_NFT_NAT=m
+CONFIG_NFT_TUNNEL=m
+CONFIG_NFT_OBJREF=m
+CONFIG_NFT_QUOTA=m
+CONFIG_NFT_REJECT=m
+CONFIG_NFT_COMPAT=m
+CONFIG_NFT_HASH=m
+CONFIG_NFT_XFRM=m
+CONFIG_NFT_SOCKET=m
+CONFIG_NFT_OSF=m
+CONFIG_NFT_TPROXY=m
+CONFIG_NFT_SYNPROXY=m
+CONFIG_NFT_DUP_NETDEV=m
+CONFIG_NFT_FWD_NETDEV=m
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CGROUP=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_IP_VS=m
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_RR=m
+CONFIG_NF_TABLES_ARP=y
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_RPFILTER=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_SYNPROXY=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_NF_LOG_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_RPFILTER=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_MATCH_SRH=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_TARGET_SYNPROXY=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_IP6_NF_TARGET_NPT=m
+CONFIG_BRIDGE=m
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CAN=y
+CONFIG_CAN_FLEXCAN=y
+CONFIG_BT=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_LL=y
+CONFIG_CFG80211=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=m
+CONFIG_MAC80211_MESH=y
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+CONFIG_NFC=y
+CONFIG_NFC_DIGITAL=y
+CONFIG_NFC_HCI=m
+CONFIG_NFC_ST25DV=m
+CONFIG_PCI=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_IMX6=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_IMX_WEIM=y
+CONFIG_CONNECTOR=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_NFTL=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_DATAFLASH=y
+CONFIG_MTD_SST25L=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_MTD_NAND_GPMI_NAND=y
+CONFIG_MTD_NAND_VF610_NFC=y
+CONFIG_MTD_NAND_MXC=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_FASTMAP=y
+CONFIG_MTD_UBI_BLOCK=y
+CONFIG_OF_OVERLAY=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=65536
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_ATA=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_IMX=y
+CONFIG_PATA_IMX=y
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=m
+CONFIG_MACVLAN=m
+CONFIG_IPVLAN=m
+CONFIG_VXLAN=m
+CONFIG_TUN=y
+CONFIG_VETH=m
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_CS89x0=y
+CONFIG_CS89x0_PLATFORM=y
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+CONFIG_8139CP=m
+CONFIG_8139TOO=m
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_SMC91X=m
+CONFIG_SMC911X=m
+CONFIG_SMSC911X=m
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_AT803X_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_SMSC_PHY=y
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_RTL8152=y
+CONFIG_USB_LAN78XX=y
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_CDC_EEM=m
+CONFIG_USB_NET_SMSC95XX=y
+CONFIG_USB_NET_MCS7830=y
+CONFIG_ATMEL=m
+CONFIG_AT76C50X_USB=m
+CONFIG_B43=m
+CONFIG_BRCMSMAC=m
+CONFIG_BRCMFMAC=m
+# CONFIG_BRCMFMAC_SDIO is not set
+CONFIG_BRCMFMAC_USB=y
+CONFIG_MT7601U=m
+CONFIG_MT76x0U=m
+CONFIG_RT2X00=m
+CONFIG_RT2500USB=m
+CONFIG_RT73USB=m
+CONFIG_RT2800USB=m
+CONFIG_RTL8180=m
+CONFIG_RTL8187=m
+CONFIG_RTL8XXXU=m
+CONFIG_RSI_91X=m
+# CONFIG_RSI_DEBUGFS is not set
+# CONFIG_RSI_SDIO is not set
+CONFIG_CW1200=m
+CONFIG_WL1251=m
+CONFIG_WL12XX=m
+CONFIG_WL18XX=m
+CONFIG_USB_NET_RNDIS_WLAN=m
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_SNVS_PWRKEY=y
+CONFIG_KEYBOARD_IMX=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=y
+CONFIG_TOUCHSCREEN_EGALAX=y
+CONFIG_TOUCHSCREEN_GOODIX=y
+CONFIG_TOUCHSCREEN_MAX11801=y
+CONFIG_TOUCHSCREEN_IMX6UL_TSC=y
+CONFIG_TOUCHSCREEN_EDT_FT5X06=y
+CONFIG_TOUCHSCREEN_MC13783=y
+CONFIG_TOUCHSCREEN_TSC2004=y
+CONFIG_TOUCHSCREEN_TSC2007=y
+CONFIG_TOUCHSCREEN_STMPE=y
+CONFIG_TOUCHSCREEN_SX8654=y
+CONFIG_TOUCHSCREEN_COLIBRI_VF50=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_MMA8450=y
+CONFIG_SERIO_SERPORT=m
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_TCG_TPM=y
+CONFIG_TCG_TIS_SPI=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_GPIO=y
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_ALGOPCF=m
+CONFIG_I2C_ALGOPCA=m
+CONFIG_I2C_GPIO=y
+CONFIG_I2C_IMX=y
+CONFIG_SPI=y
+CONFIG_SPI_DEBUG=y
+CONFIG_SPI_FSL_QUADSPI=y
+CONFIG_SPI_GPIO=y
+CONFIG_SPI_IMX=y
+CONFIG_SPI_FSL_DSPI=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_SIOX=m
+CONFIG_GPIO_MAX732X=m
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_CONEGX=m
+CONFIG_GPIO_PCF857X=y
+CONFIG_GPIO_STMPE=y
+CONFIG_GPIO_74X164=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_POWER_RESET_SYSCON_POWEROFF=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_SENSORS_MC13783_ADC=y
+CONFIG_SENSORS_GPIO_FAN=y
+CONFIG_SENSORS_IIO_HWMON=y
+CONFIG_THERMAL_STATISTICS=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_CPU_THERMAL=y
+CONFIG_IMX_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_DA9063_WATCHDOG=m
+CONFIG_DA9062_WATCHDOG=y
+CONFIG_RN5T618_WATCHDOG=y
+CONFIG_IMX2_WDT=y
+CONFIG_MFD_DA9052_I2C=y
+CONFIG_MFD_DA9062=y
+CONFIG_MFD_DA9063=y
+CONFIG_MFD_MC13XXX_SPI=y
+CONFIG_MFD_MC13XXX_I2C=y
+CONFIG_MFD_RN5T618=y
+CONFIG_MFD_STMPE=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_ANATOP=y
+CONFIG_REGULATOR_DA9052=y
+CONFIG_REGULATOR_DA9062=y
+CONFIG_REGULATOR_DA9063=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_MC13783=y
+CONFIG_REGULATOR_MC13892=y
+CONFIG_REGULATOR_PFUZE100=y
+CONFIG_REGULATOR_RN5T618=y
+CONFIG_RC_CORE=y
+CONFIG_RC_DEVICES=y
+CONFIG_IR_GPIO_CIR=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_MUX=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_CODA=m
+CONFIG_VIDEO_IMX_PXP=y
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+CONFIG_VIDEO_ADV7180=m
+CONFIG_VIDEO_OV2680=m
+CONFIG_VIDEO_OV5640=m
+CONFIG_VIDEO_OV5645=m
+CONFIG_IMX_IPUV3_CORE=y
+CONFIG_DRM=y
+CONFIG_DRM_PANEL_LVDS=y
+CONFIG_DRM_PANEL_SIMPLE=y
+CONFIG_DRM_PANEL_SEIKO_43WVF1G=y
+CONFIG_DRM_DW_HDMI_AHB_AUDIO=m
+CONFIG_DRM_DW_HDMI_CEC=y
+CONFIG_DRM_IMX=y
+CONFIG_DRM_IMX_PARALLEL_DISPLAY=y
+CONFIG_DRM_IMX_TVE=y
+CONFIG_DRM_IMX_LDB=y
+CONFIG_DRM_IMX_HDMI=y
+CONFIG_DRM_ETNAVIV=y
+CONFIG_DRM_MXSFB=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_L4F00242T03=y
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_BACKLIGHT_GPIO=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_FSL_ASRC=y
+CONFIG_SND_IMX_SOC=y
+CONFIG_SND_SOC_EUKREA_TLV320=y
+CONFIG_SND_SOC_IMX_ES8328=y
+CONFIG_SND_SOC_IMX_SGTL5000=y
+CONFIG_SND_SOC_IMX_SPDIF=y
+CONFIG_SND_SOC_IMX_MC13783=y
+CONFIG_SND_SOC_FSL_ASOC_CARD=y
+CONFIG_SND_SOC_AC97_CODEC=y
+CONFIG_SND_SOC_CS42XX8_I2C=y
+CONFIG_SND_SOC_TLV320AIC3X=y
+CONFIG_SND_SOC_WM8960=y
+CONFIG_SND_SOC_WM8962=y
+CONFIG_SND_SIMPLE_CARD=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_XHCI_HCD=m
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_MXC=y
+CONFIG_USB_ACM=m
+CONFIG_USB_WDM=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_SIMPLE=m
+CONFIG_USB_SERIAL_AIRCABLE=m
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_CH341=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_F81232=m
+CONFIG_USB_SERIAL_F8153X=m
+CONFIG_USB_SERIAL_IUU=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_USB_SERIAL_MXUPORT=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_OTI6858=m
+CONFIG_USB_SERIAL_QCAUX=m
+CONFIG_USB_SERIAL_QUALCOMM=m
+CONFIG_USB_SERIAL_SPCP8X5=m
+CONFIG_USB_SERIAL_SAFE=m
+CONFIG_USB_SERIAL_TI=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_SSU100=m
+CONFIG_USB_SERIAL_QT2=m
+CONFIG_USB_SERIAL_UPD78F0730=m
+CONFIG_USB_TEST=m
+CONFIG_USB_EHSET_TEST_FIXTURE=m
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_MXS_PHY=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_FSL_USB2=y
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_LB_SS=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_UAC1=y
+CONFIG_USB_CONFIGFS_F_UAC2=y
+CONFIG_USB_CONFIGFS_F_MIDI=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_CONFIGFS_F_UVC=y
+CONFIG_USB_CONFIGFS_F_PRINTER=y
+CONFIG_USB_ZERO=m
+CONFIG_USB_AUDIO=m
+CONFIG_USB_ETH=m
+CONFIG_USB_G_NCM=m
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_FUNCTIONFS=m
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_USB_CDC_COMPOSITE=m
+CONFIG_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_PWM=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+CONFIG_RTC_DRV_DS1307=y
+CONFIG_RTC_DRV_ISL1208=y
+CONFIG_RTC_DRV_PCF8523=y
+CONFIG_RTC_DRV_PCF8563=y
+CONFIG_RTC_DRV_M41T80=y
+CONFIG_RTC_DRV_DA9063=y
+CONFIG_RTC_DRV_MC13XXX=y
+CONFIG_RTC_DRV_MXC=y
+CONFIG_RTC_DRV_MXC_V2=y
+CONFIG_RTC_DRV_SNVS=y
+CONFIG_DMADEVICES=y
+CONFIG_FSL_EDMA=y
+CONFIG_IMX_SDMA=y
+CONFIG_MXS_DMA=y
+CONFIG_DMATEST=m
+CONFIG_STAGING=y
+CONFIG_STAGING_MEDIA=y
+CONFIG_VIDEO_IMX_MEDIA=y
+CONFIG_COMMON_CLK_PWM=y
+CONFIG_IIO=y
+CONFIG_MMA8452=y
+CONFIG_IMX7D_ADC=y
+CONFIG_VF610_ADC=y
+CONFIG_SENSORS_ISL29018=y
+CONFIG_MAG3110=y
+CONFIG_MPL3115=y
+CONFIG_PWM=y
+CONFIG_PWM_FSL_FTM=y
+CONFIG_PWM_IMX27=y
+CONFIG_PWM_IMX_TPM=y
+CONFIG_NVMEM_IMX_OCOTP=y
+CONFIG_NVMEM_VF610_OCOTP=y
+CONFIG_NVMEM_SNVS_LPGPR=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_MUX_MMIO=y
+CONFIG_SIOX=m
+CONFIG_SIOX_BUS_GPIO=m
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_BTRFS_FS=y
+CONFIG_BTRFS_FS_POSIX_ACL=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_OVERLAY_FS=y
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_JFFS2_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_UTF8=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_DH=y
+CONFIG_CRYPTO_ECRDSA=y
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_CHACHA20POLY1305=y
+CONFIG_CRYPTO_AEGIS128=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_CRYPTO_USER_API_RNG=y
+CONFIG_CRYPTO_USER_API_AEAD=y
+CONFIG_CRYPTO_DEV_FSL_CAAM=y
+CONFIG_CRYPTO_DEV_SAHARA=y
+CONFIG_CRYPTO_DEV_MXS_DCP=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CMA_SIZE_MBYTES=64
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_PROVE_LOCKING=y
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_FTRACE is not set
diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile
index e7364e6c8c6b..8d6d8617a0fa 100644
--- a/arch/arm/mach-imx/Makefile
+++ b/arch/arm/mach-imx/Makefile
@@ -85,6 +85,7 @@ obj-$(CONFIG_SOC_IMX6UL) += mach-imx6ul.o
 obj-$(CONFIG_SOC_IMX7D_CA7) += mach-imx7d.o
 obj-$(CONFIG_SOC_IMX7D_CM4) += mach-imx7d-cm4.o
 obj-$(CONFIG_SOC_IMX7ULP) += mach-imx7ulp.o pm-imx7ulp.o
+obj-$(CONFIG_SOC_IMX6) += ocotp.o
 
 ifeq ($(CONFIG_SUSPEND),y)
 AFLAGS_suspend-imx6.o :=-Wa,-march=armv7-a
diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index 5aa5796cff0e..40110f46c788 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -49,6 +49,7 @@ void imx_aips_allow_unprivileged_access(const char *compat);
 int mxc_device_init(void);
 void imx_set_soc_revision(unsigned int rev);
 void imx_init_revision_from_anatop(void);
+void imx_init_serial_from_ocotp(const char *ocotp_compat);
 struct device *imx_soc_device_init(void);
 void imx6_enable_rbc(bool enable);
 void imx_gpc_check_dt(void);
diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
index edd26e0ffeec..698a5ce64252 100644
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -306,6 +306,7 @@ static void __init imx6q_init_irq(void)
 {
 	imx_gpc_check_dt();
 	imx_init_revision_from_anatop();
+	imx_init_serial_from_ocotp("fsl,imx6q-ocotp");
 	imx_init_l2cache();
 	imx_src_init();
 	irqchip_init();
diff --git a/arch/arm/mach-imx/mach-imx6sl.c b/arch/arm/mach-imx/mach-imx6sl.c
index e00818abe54d..8fc2c82da99e 100644
--- a/arch/arm/mach-imx/mach-imx6sl.c
+++ b/arch/arm/mach-imx/mach-imx6sl.c
@@ -64,6 +64,7 @@ static void __init imx6sl_init_irq(void)
 {
 	imx_gpc_check_dt();
 	imx_init_revision_from_anatop();
+	imx_init_serial_from_ocotp("fsl,imx6sl-ocotp");
 	imx_init_l2cache();
 	imx_src_init();
 	irqchip_init();
diff --git a/arch/arm/mach-imx/mach-imx6sx.c b/arch/arm/mach-imx/mach-imx6sx.c
index d5310bf307ff..9700e07822b6 100644
--- a/arch/arm/mach-imx/mach-imx6sx.c
+++ b/arch/arm/mach-imx/mach-imx6sx.c
@@ -80,6 +80,7 @@ static void __init imx6sx_init_irq(void)
 {
 	imx_gpc_check_dt();
 	imx_init_revision_from_anatop();
+	imx_init_serial_from_ocotp("fsl,imx6sx-ocotp");
 	imx_init_l2cache();
 	imx_src_init();
 	irqchip_init();
diff --git a/arch/arm/mach-imx/mach-imx6ul.c b/arch/arm/mach-imx/mach-imx6ul.c
index 311f5e4ff723..5a618bfcb1dc 100644
--- a/arch/arm/mach-imx/mach-imx6ul.c
+++ b/arch/arm/mach-imx/mach-imx6ul.c
@@ -11,8 +11,10 @@
 #include <linux/regmap.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
+#include <asm/system_info.h>
 
 #include "common.h"
+#include "hardware.h"
 #include "cpuidle.h"
 
 static void __init imx6ul_enet_clk_init(void)
@@ -31,11 +33,11 @@ static void __init imx6ul_enet_clk_init(void)
 static int ksz8081_phy_fixup(struct phy_device *dev)
 {
 	if (dev && dev->interface == PHY_INTERFACE_MODE_MII) {
-		phy_write(dev, 0x1f, 0x8110);
-		phy_write(dev, 0x16, 0x201);
+		/* Override strap-in for MII mode */
+		phy_write(dev, 0x16, 0x1);
 	} else if (dev && dev->interface == PHY_INTERFACE_MODE_RMII) {
-		phy_write(dev, 0x1f, 0x8190);
-		phy_write(dev, 0x16, 0x202);
+		/* Override strap-in for RMII mode */
+		phy_write(dev, 0x16, 0x2);
 	}
 
 	return 0;
@@ -58,6 +60,10 @@ static void __init imx6ul_init_machine(void)
 {
 	struct device *parent;
 
+	system_rev = imx_get_soc_revision();
+	imx_print_silicon_rev(cpu_is_imx6ull() ? "i.MX 6ULL" : "i.MX 6UL",
+            system_rev);
+
 	parent = imx_soc_device_init();
 	if (parent == NULL)
 		pr_warn("failed to initialize soc device\n");
@@ -71,6 +77,8 @@ static void __init imx6ul_init_machine(void)
 static void __init imx6ul_init_irq(void)
 {
 	imx_init_revision_from_anatop();
+	imx_init_serial_from_ocotp(cpu_is_imx6ull() ? "fsl,imx6ull-ocotp" :
+		"fsl,imx6ul-ocotp");
 	imx_src_init();
 	irqchip_init();
 	imx6_pm_ccm_init("fsl,imx6ul-ccm");
diff --git a/arch/arm/mach-imx/ocotp.c b/arch/arm/mach-imx/ocotp.c
new file mode 100644
index 000000000000..8bd953c19cc0
--- /dev/null
+++ b/arch/arm/mach-imx/ocotp.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 PHYTEC Messtechnik GmbH,
+ * Author: Stefan Christ <s.christ@phytec.de>
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <asm/system_info.h>
+
+#include "common.h"
+
+#define OCOTP_CFG0			0x410
+#define OCOTP_CFG1			0x420
+
+void __init imx_init_serial_from_ocotp(const char* ocotp_compat)
+{
+	struct device_node *np;
+	void __iomem *base;
+
+	np = of_find_compatible_node(NULL, NULL, ocotp_compat);
+	if (!np) {
+		pr_warn("failed to find ocotp node in dtb!\n");
+		return;
+	}
+
+	base = of_iomap(np, 0);
+	if (!base) {
+		pr_warn("failed to map ocotp\n");
+		goto put_node;
+	}
+
+	system_serial_high = readl_relaxed(base + OCOTP_CFG0);
+	system_serial_low  = readl_relaxed(base + OCOTP_CFG1);
+
+	iounmap(base);
+put_node:
+	of_node_put(np);
+}
diff --git a/drivers/cpufreq/imx6q-cpufreq.c b/drivers/cpufreq/imx6q-cpufreq.c
index edef3399c979..bc60949aabea 100644
--- a/drivers/cpufreq/imx6q-cpufreq.c
+++ b/drivers/cpufreq/imx6q-cpufreq.c
@@ -14,14 +14,19 @@
 #include <linux/pm_opp.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
+#include <linux/suspend.h>
 
 #define PU_SOC_VOLTAGE_NORMAL	1250000
 #define PU_SOC_VOLTAGE_HIGH	1275000
+#define DC_VOLTAGE_MIN		1300000
+#define DC_VOLTAGE_MAX		1400000
 #define FREQ_1P2_GHZ		1200000000
+#define FREQ_528_MHZ		528000
 
 static struct regulator *arm_reg;
 static struct regulator *pu_reg;
 static struct regulator *soc_reg;
+static struct regulator *dc_reg;
 
 enum IMX6_CPUFREQ_CLKS {
 	ARM,
@@ -56,6 +61,8 @@ static unsigned int transition_latency;
 static u32 *imx6_soc_volt;
 static u32 soc_opp_count;
 
+static bool ignore_dc_reg;
+
 static int imx6q_set_target(struct cpufreq_policy *policy, unsigned int index)
 {
 	struct dev_pm_opp *opp;
@@ -327,6 +334,43 @@ static int imx6ul_opp_check_speed_grading(struct device *dev)
 	return ret;
 }
 
+static int imx6_cpufreq_pm_notify(struct notifier_block *nb,
+	unsigned long event, void *dummy)
+{
+	int ret;
+
+	switch (event) {
+	case PM_SUSPEND_PREPARE:
+		if (!IS_ERR(dc_reg) && !ignore_dc_reg) {
+			ret = regulator_set_voltage_tol(dc_reg, DC_VOLTAGE_MAX, 0);
+			if (ret) {
+				dev_err(cpu_dev,
+					"failed to scale dc_reg to max: %d\n", ret);
+				return ret;
+			}
+		}
+		break;
+	case PM_POST_SUSPEND:
+		if (!IS_ERR(dc_reg) && !ignore_dc_reg) {
+			ret = regulator_set_voltage_tol(dc_reg, DC_VOLTAGE_MIN, 0);
+			if (ret) {
+				dev_err(cpu_dev,
+					"failed to scale dc_reg to min: %d\n", ret);
+				return ret;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block imx6_cpufreq_pm_notifier = {
+	.notifier_call = imx6_cpufreq_pm_notify,
+};
+
 static int imx6q_cpufreq_probe(struct platform_device *pdev)
 {
 	struct device_node *np;
@@ -375,6 +419,8 @@ static int imx6q_cpufreq_probe(struct platform_device *pdev)
 		goto put_reg;
 	}
 
+	dc_reg = regulator_get_optional(cpu_dev, "dc");
+
 	ret = dev_pm_opp_of_add_table(cpu_dev);
 	if (ret < 0) {
 		dev_err(cpu_dev, "failed to init OPP table: %d\n", ret);
@@ -412,6 +458,21 @@ static int imx6q_cpufreq_probe(struct platform_device *pdev)
 		goto out_free_opp;
 	}
 
+	/*
+	 * On i.MX6UL/ULL EVK board, if the SOC is run in overide frequency,
+	 * the dc_regulator voltage should not be touched.
+	 */
+	if (freq_table[num - 1].frequency > FREQ_528_MHZ)
+		ignore_dc_reg = true;
+	if (!IS_ERR(dc_reg) && !ignore_dc_reg) {
+		ret = regulator_set_voltage_tol(dc_reg, DC_VOLTAGE_MIN, 0);
+		if (ret) {
+			dev_err(cpu_dev,
+				"failed to scale dc_reg to min: %d\n", ret);
+			return ret;
+		}
+	}
+
 	/* Make imx6_soc_volt array's size same as arm opp number */
 	imx6_soc_volt = devm_kcalloc(cpu_dev, num, sizeof(*imx6_soc_volt),
 				     GFP_KERNEL);
@@ -494,6 +555,8 @@ static int imx6q_cpufreq_probe(struct platform_device *pdev)
 		goto free_freq_table;
 	}
 
+	register_pm_notifier(&imx6_cpufreq_pm_notifier);
+
 	of_node_put(np);
 	return 0;
 
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index ae414045a750..7b62432cdd28 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -916,6 +916,12 @@ config GPIO_PCA953X_IRQ
 	  Say yes here to enable the pca953x to be used as an interrupt
 	  controller. It requires the driver to be built in the kernel.
 
+config GPIO_CONEGX
+	tristate "Conegx Gpio Expander and Power watch"
+	select GPIOLIB_IRQCHIP
+	help
+	  Consolinno Energy Conegx Module.
+
 config GPIO_PCF857X
 	tristate "PCF857x, PCA{85,96}7x, and MAX732[89] I2C GPIO expanders"
 	select GPIOLIB_IRQCHIP
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index d2fd19c15bae..3653f2b6b030 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -40,6 +40,7 @@ obj-$(CONFIG_GPIO_BRCMSTB)		+= gpio-brcmstb.o
 obj-$(CONFIG_GPIO_BT8XX)		+= gpio-bt8xx.o
 obj-$(CONFIG_GPIO_CADENCE)		+= gpio-cadence.o
 obj-$(CONFIG_GPIO_CLPS711X)		+= gpio-clps711x.o
+obj-$(CONFIG_GPIO_CONEGX)		+= gpio-conegx.o
 obj-$(CONFIG_GPIO_SNPS_CREG)		+= gpio-creg-snps.o
 obj-$(CONFIG_GPIO_CRYSTAL_COVE)		+= gpio-crystalcove.o
 obj-$(CONFIG_GPIO_CS5535)		+= gpio-cs5535.o
@@ -169,3 +170,4 @@ obj-$(CONFIG_GPIO_XTENSA)		+= gpio-xtensa.o
 obj-$(CONFIG_GPIO_ZEVIO)		+= gpio-zevio.o
 obj-$(CONFIG_GPIO_ZX)			+= gpio-zx.o
 obj-$(CONFIG_GPIO_ZYNQ)			+= gpio-zynq.o
+
diff --git a/drivers/gpio/gpio-conegx.c b/drivers/gpio/gpio-conegx.c
new file mode 100644
index 000000000000..c0ec9614cfaf
--- /dev/null
+++ b/drivers/gpio/gpio-conegx.c
@@ -0,0 +1,1334 @@
+/**
+ * @file gpio-conegx.c
+ * @author A. Pietsch (a.pietsch@consolinno.de)
+ * @brief Driver for Consolinno Conegx Module
+ * @version 1.1.5
+ * @date 2021-06-22
+ * 
+ * @copyright: Copyrigth (c) 2021
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ * 
+ */
+
+/*This enables some Prints and IRQ Testing for powerfail and voltagerange.
+when enabled triggering MRES irqs will simulate IRQS for powerfail and 
+voltagerange
+*/
+//#define CONEGX_TESTING
+
+#include "gpio-conegx.h"
+
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/gpio/driver.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/kdev_t.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of_irq.h>
+#include <linux/proc_fs.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+
+#define ldev_to_led(c) container_of(c, struct conegx_led, ldev)
+
+/* Global Variables ---------------------------------------------------------*/
+static struct conegx *Conegx;
+
+/* Device File */
+static dev_t ConDevNr = 0;
+static struct class *ConDevClass;
+static struct device *ConDevice;
+static struct cdev *ConDriverObject;
+
+/* IRQ */
+static wait_queue_head_t IrSleepingQeue;
+static int InterruptArrived = 0;
+
+/* Proc FS */
+static struct proc_dir_entry *ProcfsParent;
+
+/* Function Prototypes */
+static int reset_MSP430(void);
+
+/*---------------GPIO Functions---------------*/
+static int conegx_get_direction(struct gpio_chip *chip, unsigned offset);
+static int conegx_get_gpio(struct gpio_chip *chip, unsigned offset);
+static int conegx_set_gpio(unsigned offset, int value);
+static void set_gpio(struct gpio_chip *chip, unsigned offset, int value);
+static int conegx_direction_input(struct gpio_chip *chip, unsigned offset);
+static int conegx_direction_output(struct gpio_chip *chip, unsigned offset,
+                                   int val);
+/*---------------PROCFS Functions---------------*/
+static ssize_t read_proc_fwversion(
+    struct file *filp, 
+    char __user *buffer,
+    size_t length, 
+    loff_t *offset);
+
+static ssize_t write_proc_tstbuttonlock(
+    struct file *filp, 
+    const char *buff,
+    size_t len, 
+    loff_t *off);
+
+static ssize_t read_proc_tstbuttonlock(
+    struct file *filp, 
+    char __user *buffer,
+    size_t length, 
+    loff_t *offset);
+
+static ssize_t write_proc_rstbuttonlock(
+    struct file *filp, 
+    const char *buff,
+    size_t len, 
+    loff_t *off);
+
+static ssize_t read_proc_rstbuttonlock(
+    struct file *filp, 
+    char __user *buffer,
+    size_t length, 
+    loff_t *offset);
+
+static ssize_t read_proc_resetmsp(
+    struct file *filp, 
+    char __user *buffer,
+    size_t length, 
+    loff_t *offset);
+
+/**
+ * @brief Struct for Register Map Configuration
+ * 
+ */
+const struct regmap_config ConegxRegmap = {
+    .reg_bits = 8,
+    .val_bits = 8,
+    .max_register = GET_BUTTON_LOCK << 1,
+    //.reg_defaults = conegx_defaults,
+    .num_reg_defaults = ARRAY_SIZE(conegx_reg_access)};
+EXPORT_SYMBOL_GPL(ConegxRegmap);
+
+/*---------------GPIO---------------------------------------------------------*/
+
+/**
+ * @brief Get Direction of the GPIOs
+ * 
+ * @param chip Gpio Chip
+ * @param offset Gpio Number 
+ * @return int  succesfull returns 0 , failure -1
+ */
+static int conegx_get_direction(struct gpio_chip *chip, unsigned offset) 
+{
+    int Direction;
+    
+    if((offset >= IO_RELAY_1) && (offset <= IO_PFI_4))
+    {
+        Direction = conegx_directions[offset];
+    }
+    else
+    {
+        Direction = -1;
+    }
+
+    return Direction;
+}
+
+/**
+ * @brief Get Status of the GPIOs
+ * 
+ * @param chip Gpio Chip
+ * @param offset Gpio Number 
+ * @return int  succesfull returns 0 , failure -1
+ */
+static int conegx_get_gpio(struct gpio_chip *chip, unsigned offset) 
+{
+    uint Buffer = 0;
+    int Ret = 0;
+    int RegisterAdress = 0;
+    bool readRegMap = false;
+
+    pr_debug("conegx: getting gpio %d %s\n", offset, conegx_gpio_names[offset]);
+
+    /* read GET RELAY PORT */
+    if(IO_RELAY_1 <= offset && offset <= IO_RELAY_4) 
+    {
+        RegisterAdress = GET_RELAY_PORT;
+        Buffer = Conegx->SetRelayBuffer;
+    }
+    /* read GET INPUT PINS */
+    else if(IO_FLT_HBUS24 <= offset && offset <= IO_PFI_4) 
+    {
+        RegisterAdress = GET_INPUT_PORT;
+        offset -= IO_FLT_HBUS24;
+        readRegMap = true;
+    } 
+    else 
+    {
+        return -1;
+    }
+
+    mutex_lock(&Conegx->lock);
+    if(readRegMap)
+    {
+        Ret = regmap_read(Conegx->regmap, RegisterAdress, &Buffer);
+        mdelay(I2C_DELAY);
+        pr_debug("conegx: Reading Register 0x%x: 0x%x\n", RegisterAdress, Buffer);
+        if(Ret) 
+        {
+            printk(KERN_ERR "conegx: Error reading conegx gpio %d\n", offset);
+
+            reset_MSP430();
+
+            mutex_unlock(&Conegx->lock);
+            return Ret;
+        }
+    }
+
+    mutex_unlock(&Conegx->lock);
+    return !!(Buffer & BIT(offset));
+}
+
+/**
+ * @brief Get GPio Status
+ * 
+ * @param offset Gpio Number	
+ * @param value 1 for Active/HIGH, 0 for Inactive/LOW
+ * @return int  succesfull returns 0 , failure -1
+ */
+static int conegx_set_gpio(unsigned offset, int value) 
+{
+    uint Buffer, NewValue;
+    int Ret, RegisterAdress = 0;
+    int InternalRegisterOffset;
+    __u8 *RegisterBuffer = NULL;
+    unsigned int led_no;
+
+    pr_debug("conegx: setting gpio %d %s to %d\n",
+            offset, conegx_gpio_names[offset], value);
+
+    /* Shift offset/pin to conegx numbers */
+
+    /* Get InternalRegister and InternalRegister Offset */
+    if(IO_RELAY_1 <= offset && offset <= IO_RELAY_4) 
+    {
+        RegisterAdress = SET_RELAY_PORT;
+        RegisterBuffer = &Conegx->SetRelayBuffer;
+        Buffer = Conegx->SetRelayBuffer;
+        InternalRegisterOffset = offset - IO_RELAY_1;
+
+        /* If a relay is closed or opened, the Firmware 
+        turns the associated LED on or off. We reflect this behaviour here. */
+        
+        switch(offset)
+        {
+            case IO_RELAY_1: // S_1
+            {
+                led_no = IO_LED_4;
+            }break;
+
+            case IO_RELAY_2: // S_2
+            {
+                led_no = IO_LED_5;
+            }break;
+
+            case IO_RELAY_3: // W_3
+            {
+                led_no = IO_LED_3;
+            }break;
+
+            case IO_RELAY_4: // W_4
+            {
+                led_no = IO_LED_6;
+            }break;
+
+            default:
+            {
+                return -1;
+            }            
+        }
+
+        if(value)
+        {
+            Conegx->SetLedPort0Buffer |= BIT(led_no);
+        }
+        else
+        {
+            Conegx->SetLedPort0Buffer &= ~(BIT(led_no));
+        }
+    }
+    else
+    {
+        return -1;
+    } 
+
+    /* Modify Bits in Buffer */
+    if(value)
+    {
+        NewValue = Buffer | BIT(InternalRegisterOffset);
+    }
+    else
+    {
+        NewValue = Buffer & ~(BIT(InternalRegisterOffset));
+    }
+    /* Write buffer to Register if the buffer changed.*/
+    //if(NewValue != Buffer)
+    if(true)
+    {
+        mutex_lock(&Conegx->lock);
+        Ret = regmap_write(Conegx->regmap, RegisterAdress, NewValue);
+        mdelay(I2C_DELAY);
+        pr_debug("conegx: Writing Register 0x%x: 0x%x\n", RegisterAdress, NewValue);
+        if(Ret) 
+        {
+            printk(KERN_ERR "conegx: Error writing to Register 0x%x\n",
+                RegisterAdress);
+
+            reset_MSP430();
+
+            mutex_unlock(&Conegx->lock);
+            return -1;  
+        } 
+        else 
+        {
+            /* Update RegisterBuffer */
+            *RegisterBuffer = NewValue;
+        }
+
+        mutex_unlock(&Conegx->lock);
+    }
+    
+    return 0;
+}
+
+/**
+ * @brief Set the gpio Value
+ * 
+ * @param chip Gpio Chip
+ * @param offset Gpio Number
+ * @param value High or Low Value
+ */
+static void set_gpio(struct gpio_chip *chip, unsigned offset, int value) 
+{
+    /* call Conegx Gpio Set Function */
+    conegx_set_gpio(offset, value);
+}
+
+/**
+ * @brief Set Direction to INPUT 
+ * 
+ * @param chip Gpio Chip
+ * @param offset Gpio Number
+ * @return int  succesfull returns 0 , failure -1
+ */
+static int conegx_direction_input(struct gpio_chip *chip, unsigned offset) 
+{
+    pr_debug("conegx: setting direction INPUT for gpio %d %s\n",
+            offset, conegx_gpio_names[offset]);
+
+    /* Return error for Relais Outputs */
+    if(IO_RELAY_1 <= offset && offset <= IO_RELAY_4) 
+    {
+        return -1;
+    }
+    
+    return 0;
+}
+
+/**
+ * @brief Set Gpio Direction to Output
+ * 
+ * @param chip Gpio Chip
+ * @param offset Gpio Number
+ * @param val Inital Gpio Status after setting: High or Low 
+ * @return int  succesfull returns 0 , failure -1
+ */
+static int conegx_direction_output(
+    struct gpio_chip *chip,
+    unsigned offset, 
+    int val) 
+{
+    pr_debug("conegx: setting direction OUTPUT for gpio %d %s\n",
+            offset, conegx_gpio_names[offset]);
+
+    if(IO_FLT_HBUS24 <= offset && offset <= IO_PFI_4) 
+    {
+        return -1;
+    }
+    // set actual gpio values
+    return conegx_set_gpio(offset, val);
+}
+/*---------------FS-----------------------------------------------------------*/
+
+/**
+ * @brief Read Function of the device File /dev/conegx
+ */
+static ssize_t con_devfile_read(
+    struct file *instanz, 
+    char __user *user,
+    size_t count, 
+    loff_t *offset) 
+{
+    char IRQNumberChar[4];
+    int BytesRead;
+    int BytesToRead = sizeof(IRQNumberChar) - *offset;
+
+    memset(IRQNumberChar, 0, sizeof(IRQNumberChar));
+
+    // If we are at the end of the file, STOP READING!
+    if(BytesToRead == 0) 
+    {
+        return BytesToRead;
+    }
+
+    /* Wait for Change */
+    pr_debug("conegx: Someone is now listening to DevFile for IRQ numbers\n");
+    Conegx->IRQDeviceFileEnabled = 1;
+    InterruptArrived = 0;
+    wait_event_interruptible(IrSleepingQeue, InterruptArrived);
+
+    /* GetCharversion */
+    sprintf(IRQNumberChar, "%-2d\n", Conegx->LastInterruptNr);
+
+    // Get bytes read by subtracting return of copy_to_user (returns unread bytes)
+
+    BytesRead = BytesToRead - copy_to_user(user, IRQNumberChar + *offset,
+                                           BytesToRead);
+
+    // Set offset so that we can eventually reach the end of the file
+    *offset += BytesRead;
+    Conegx->IRQDeviceFileEnabled = 0;
+    return BytesRead;
+}
+
+/**
+ * @brief File Operation Struct for /dev/conegx
+ */
+static struct file_operations fops_devfile = {
+    .owner = THIS_MODULE,
+    .read = con_devfile_read,
+};
+
+/*---------------PROCFS-------------------------------------------------------*/
+/**
+ * @brief File Operation Struct for /proc/conegx/tstbuttonlock
+ */
+static struct file_operations proc_fops_tstbuttonlock = {
+
+    .read = read_proc_tstbuttonlock,
+    .write = write_proc_tstbuttonlock,
+
+};
+
+/**
+ * @brief File Operation Struct for /proc/conegx/rstbuttonlock
+ */
+static struct file_operations proc_fops_rstbuttonlock = {
+
+    .read = read_proc_rstbuttonlock,
+    .write = write_proc_rstbuttonlock,
+
+};
+
+/**
+ * @brief File Operation Struct for /proc/conegx/fwversion
+ */
+static struct file_operations proc_fops_fwversion = {
+
+    .read = read_proc_fwversion,
+
+};
+
+/**
+ * @brief File Operation Struct for /proc/conegx/resetmsp
+ */
+static struct file_operations proc_fops_resetmsp = {
+
+    .read = read_proc_resetmsp,
+
+};
+
+/**
+ * @brief Read Function  for /proc/conegx/fwversion
+ */
+static ssize_t read_proc_fwversion(
+    struct file *filp, 
+    char __user *buffer,
+    size_t length, 
+    loff_t *offset) 
+{
+    int BytesRead;
+    int BytesToRead = sizeof(Conegx->FwVersion) - *offset;
+
+    // If we are at the end of the file, STOP READING!
+    if(BytesToRead == 0) 
+    {
+        return BytesToRead;
+    }
+
+    // Get bytes read by subtracting return of copy_to_user
+    BytesRead = BytesToRead - copy_to_user(buffer, Conegx->FwVersion + *offset,
+                                           BytesToRead);
+
+    printk("conegx: Reading %d bytes Fw Version: %s\n",
+           BytesRead, Conegx->FwVersion);
+
+    // Set offset so that we can eventually reach the end of the file
+    *offset += BytesRead;
+    return BytesRead;
+}
+
+static ssize_t read_proc_resetmsp(
+    struct file *filp, 
+    char __user *buffer,
+    size_t length, 
+    loff_t *offset)
+{
+    reset_MSP430();
+
+    return 0;
+}
+
+/**
+ * @brief Read Function  for /proc/conegx/testbuttonlock
+ */
+static ssize_t read_proc_tstbuttonlock(
+    struct file *filp,
+    char __user *buffer,
+    size_t length,
+    loff_t *offset) 
+{
+    char TstButtonLockChar[2];
+    int BytesRead;
+    int BytesToRead = 2 - *offset;
+
+    TstButtonLockChar[0] = (char)(Conegx->TstButtonLock + '0');
+    TstButtonLockChar[1] = '\n';
+
+    // If we are at the end of the file, STOP READING!
+    if(BytesToRead == 0) 
+    {
+        return BytesToRead;
+    }
+
+    // Get bytes read by subtracting return of copy_to_user
+    BytesRead = BytesToRead - copy_to_user(buffer, TstButtonLockChar + *offset,
+                                           BytesToRead);
+
+    printk("conegx: Reading %d bytes TstButon Range: %c\n",
+           BytesRead, TstButtonLockChar[0]);
+
+    // Set offset so that we can eventually reach the end of the file
+    *offset += BytesRead;
+    return BytesRead;
+}
+
+/**
+ * @brief Write Function  for /proc/conegx/testbuttonlock
+ */
+static ssize_t write_proc_tstbuttonlock(
+    struct file *filp,
+    const char *buff,
+    size_t len,
+    loff_t *off) 
+{
+    int Ret;
+    unsigned long long TstButtonLockBuffer;
+
+    Ret = kstrtoull_from_user(buff, len, 10, &TstButtonLockBuffer);
+    if(Ret) 
+    {
+        /* Negative error code. */
+        pr_debug("conegx: Error converting ButtonLock RetVal = %d\n", Ret);
+        return Ret;
+    } 
+    else 
+    {
+        /* Check if Value is in Range */
+        if(TstButtonLockBuffer == 1 || TstButtonLockBuffer == 0) 
+        {
+            /* Set Button Lock for Tst button */
+            Conegx->TstButtonLock = TstButtonLockBuffer;
+        } 
+        else 
+        {
+            return -1;
+        }
+
+        pr_debug("conegx: Setting ButtonLock to: %d \n",
+               (Conegx->TstButtonLock | (Conegx->RstButtonLock << 4)));
+        *off = len;
+
+        /* Write Setting to Conegx */
+        Ret = regmap_write(Conegx->regmap, SET_BUTTON_LOCK,
+                           (Conegx->TstButtonLock |
+                            (Conegx->RstButtonLock << 4)));
+        mdelay(I2C_DELAY);
+        if(Ret) 
+        {
+            printk(KERN_ERR
+                   "conegx: Error writing to Register \
+							SET_BUTTON_LOCK\n");
+
+            reset_MSP430();
+
+            return -1;
+        }
+    }
+
+    return len;
+}
+
+/**
+ * @brief Read Function  for /proc/conegx/rstbuttonlock
+ */
+static ssize_t read_proc_rstbuttonlock(
+    struct file *filp, 
+    char __user *buffer,
+    size_t length, 
+    loff_t *offset) 
+{
+    char RstButtonLockChar[2];
+    int BytesRead;
+    int BytesToRead = 2 - *offset;
+
+    RstButtonLockChar[0] = (char)(Conegx->RstButtonLock + '0');
+    RstButtonLockChar[1] = '\n';
+
+    // If we are at the end of the file, STOP READING!
+    if(BytesToRead == 0) 
+    {
+        return BytesToRead;
+    }
+
+    // Get bytes read by subtracting return of copy_to_user
+    BytesRead = BytesToRead - copy_to_user(buffer,
+                                           RstButtonLockChar + *offset,
+                                           BytesToRead);
+    printk("conegx: Reading %d bytes TstButon Range: %c\n",
+           BytesRead, RstButtonLockChar[0]);
+
+    // Set offset so that we can eventually reach the end of the file
+    *offset += BytesRead;
+    return BytesRead;
+}
+
+/**
+ * @brief Write Function  for /proc/conegx/rstbuttonlock
+ */
+static ssize_t write_proc_rstbuttonlock(
+    struct file *filp,
+    const char *buff,
+    size_t len, 
+    loff_t *off) 
+{
+    int Ret;
+    unsigned long long RstButtonLockBuffer;
+
+    Ret = kstrtoull_from_user(buff, len, 10, &RstButtonLockBuffer);
+    if(Ret) 
+    {
+        /* Negative error code. */
+        pr_debug("conegx: Error converting ButtonLock RetVal = %d\n", Ret);
+        return Ret;
+    } 
+    else 
+    {
+        /* Check if Value is in Range */
+        if(RstButtonLockBuffer == 1 || RstButtonLockBuffer == 0) 
+        {
+            /* Set Button Lock for Tst button */
+            pr_debug("conegx: ResetButtonLockbuffer = %lld\n",
+                    RstButtonLockBuffer);
+
+            Conegx->RstButtonLock = RstButtonLockBuffer;
+        } 
+        else 
+        {
+            return -1;
+        }
+
+        pr_debug("conegx: Setting ButtonLock to: %d \n",
+               (Conegx->TstButtonLock | (Conegx->RstButtonLock << 4)));
+
+        *off = len;
+
+        /* Write Setting to Conegx */
+        Ret = regmap_write(Conegx->regmap, SET_BUTTON_LOCK,
+                           (Conegx->TstButtonLock |
+                            (Conegx->RstButtonLock << 4)));
+        mdelay(I2C_DELAY);
+        if(Ret) 
+        {
+            printk(KERN_ERR
+                   "conegx: Error writing to Register \
+			SET_BUTTON_LOCK\n");
+
+            reset_MSP430();
+
+            return -1;
+        }
+    }
+
+    return len;
+}
+
+/*---------------IRQ----------------------------------------------------------*/
+/**
+ * @brief IRQ Handler
+ */
+static irqreturn_t conegx_irq(int irq, void *data) 
+{
+    int Ret;
+    uint IrqNumber;
+    int ChildIRQ;
+    int GpioNumber;
+    int Edge;
+
+    mutex_lock(&Conegx->lock);
+
+    /* Read Alert Register */
+    Ret = regmap_read(Conegx->regmap, ALERT, &IrqNumber);
+    mdelay(I2C_DELAY);
+    if(Ret) 
+    {
+        printk(KERN_ERR "conegx: Error reading ALERT REGISTER\n");
+        mutex_unlock(&Conegx->lock);
+        return Ret;
+    }
+
+    mutex_unlock(&Conegx->lock);
+    Conegx->LastInterruptNr = IrqNumber;
+
+    pr_debug("conegx: IRQ detected. Interrupt Nr.: %d\n", IrqNumber);
+
+    /* GPIO INTERRUPTS -------------------*/
+    if(IrqNumber >= POTENTIAL_FREE_INPUT_1_RISING_EDGE &&
+        IrqNumber <= MRES_S2_FALLING_EDGE) 
+    {
+        /* Get Gpio Number and Edge from IRQ Number */
+        GpioNumber = conegx_gpio_irq_map[IrqNumber -
+                                         POTENTIAL_FREE_INPUT_1_RISING_EDGE][0];
+
+        Edge = conegx_gpio_irq_map[IrqNumber -
+                                   POTENTIAL_FREE_INPUT_1_RISING_EDGE][1];
+
+        pr_debug("conegx: Interrupt on GPIONR: %d",
+                GpioNumber);
+
+        if(Edge) 
+        {
+            pr_debug("conegx: Rising Edge on %s\n",
+                    conegx_gpio_names[GpioNumber]);
+        } 
+        else 
+        {
+            pr_debug("conegx: Falling Edge on %s\n",
+                    conegx_gpio_names[GpioNumber]);
+        }
+
+        /* This wakeups are just for testing */
+        #ifdef CONEGX_TESTING
+        VoltageInterruptArrived += 1;
+        PowerFailInterruptArrived += 1;      
+        #endif // DEBUG
+        
+        //#ifdef GPIOLIB_IRQCHIP
+        /* Trigger nested IRQ for GPIOS */
+        ChildIRQ = irq_find_mapping(Conegx->chip.irq.domain, GpioNumber);
+        pr_debug("conegx: handling childirq %d\n", ChildIRQ);
+        handle_nested_irq(ChildIRQ);
+
+        //#endif
+    }
+
+    /* Check if any IRQ is enabled and wake up Sleeping Queue */
+    if(Conegx->IRQDeviceFileEnabled || Conegx->IRQVoltageRangeEnabled ||
+        Conegx->IRQPowerFailEnabled) 
+    {
+        InterruptArrived += 1;
+        wake_up(&IrSleepingQeue);
+    }
+    return IRQ_HANDLED;
+}
+/* LED -----------------------------------------------------------------------*/
+
+/**
+ * @brief Led Set Brightness Function
+ */
+static int conegxled_set_brightness(
+    struct led_classdev *led_cdev,
+    enum led_brightness value) 
+{
+    uint Buffer, NewValue;
+    int Ret, RegisterAdress = 0;
+    int InternalRegisterOffset;
+    __u8 *RegisterBuffer = NULL;
+    struct conegx_led *led = ldev_to_led(led_cdev);
+
+    if(IO_LED_1 <= led->led_no && led->led_no <= IO_LED_6) 
+    {
+        RegisterAdress = SET_LED_PORT_0;
+        RegisterBuffer = &Conegx->SetLedPort0Buffer;
+        Buffer = Conegx->SetLedPort0Buffer;
+        InternalRegisterOffset = led->led_no;
+    } 
+    else if(IO_RGBLED_1_1 <= led->led_no && led->led_no <= IO_RGBLED_1_3) 
+    {
+        RegisterAdress = SET_LED_PORT_1;
+        RegisterBuffer = &Conegx->SetLedPort1Buffer;
+        Buffer = Conegx->SetLedPort1Buffer;
+        InternalRegisterOffset = led->led_no - IO_RGBLED_1_1;
+    }
+    else
+    {
+        return -1;
+    }
+
+    /* Modify Bits in Buffer */
+    if(value) 
+    {
+        NewValue = Buffer | BIT(InternalRegisterOffset);
+        pr_debug("conegx: Turn ON LED Number: %d %s\n", led->led_no, led->name);
+    } 
+    else
+    {
+        NewValue = Buffer & ~(BIT(InternalRegisterOffset));
+        pr_debug("conegx: Turn OFF LED Number: %d %s\n", led->led_no, led->name);
+    }
+    /* Write new value to Register if it has changed. */
+    //if(NewValue != Buffer)
+    if(true)
+    {
+        mutex_lock(&Conegx->lock);
+        Ret = regmap_write(Conegx->regmap, RegisterAdress, NewValue);
+        mdelay(I2C_DELAY);
+        pr_debug("conegx: Writing Register 0x%x: 0x%x\n", RegisterAdress, NewValue);
+        if(Ret) 
+        {
+            printk(KERN_ERR "conegx: Error writing to Register 0x%x\n",
+                RegisterAdress);
+
+            reset_MSP430();
+
+            mutex_unlock(&Conegx->lock);
+            return -1;
+        } 
+        else 
+        {
+            /* Update RegisterBuffer */
+            *RegisterBuffer = NewValue;
+        }
+
+        mutex_unlock(&Conegx->lock);
+    }
+    
+    return 0;
+}
+
+/**
+ * @brief Remove function for LEDS
+ */
+static int unregister_leds(int NrOfLeds) 
+{
+    int i;
+    /* unregister already registered leds */
+
+    for (i = 0; i < NrOfLeds; i++) 
+    {
+        led_classdev_unregister(&Conegx->leds[i].ldev);
+    }
+    return 0;
+}
+
+/**
+ * @brief Setup Function for LEDS
+ */
+static int setup_leds(struct i2c_client *client) 
+{
+    unsigned int i;
+    int Err;
+    pr_debug("conegx: Setting up Leds\n");
+    for (i = 0; i < NR_OF_LEDS; i++) 
+    {
+        struct conegx_led *Led = &Conegx->leds[i];
+        Led->led_no = i;
+        Led->name = conegx_led_names[i];
+        Led->ldev.brightness_set_blocking = conegxled_set_brightness;
+        Led->ldev.max_brightness = LED_FULL;
+        Led->ldev.name = conegx_led_names[i];
+        //Led->ldev.default_trigger = NULL;
+        Err = led_classdev_register(&client->dev, &Led->ldev);
+        if(Err < 0) 
+        {
+            dev_err(&client->dev, "couldn't register LED %s\n",
+                    Led->ldev.name);
+            unregister_leds(i);
+            return -1;
+        }
+        mutex_lock(&Led->ldev.led_access);
+		led_sysfs_enable(&Led->ldev);
+		mutex_unlock(&Led->ldev.led_access);
+    }
+
+    return 0;
+}
+
+/**
+ * @brief Function that Mirrors all Conegx Registers to the driver at startup
+ */
+static int conegx_getRegister(void) 
+{
+    int Ret;
+    int Val;
+    int FwVersionMaj;
+    int FwVersionMin;
+    int FwVersionPatch;
+
+    pr_debug("conegx: Collecting Device Infos:\n");
+    /* Reading GPIO and LED States into buffers Register to identify chip */
+
+    mutex_lock(&Conegx->lock);
+
+    Ret = regmap_read(Conegx->regmap, GET_RELAY_PORT, &Val);
+    mdelay(I2C_DELAY);
+    if(Ret < 0) 
+    {
+        printk(KERN_ERR "conegx: can't read GET_RELAY_PORT Register\n");
+    } 
+    else 
+    {
+        Conegx->SetRelayBuffer = (char)(Val & 0xFF);
+        pr_debug("conegx: GET_RELAY_PORT: 0x%x\n", Val);
+    }
+
+    Ret = regmap_read(Conegx->regmap, GET_LED_PORT_0, &Val);
+    mdelay(I2C_DELAY);
+    if(Ret < 0) 
+    {
+        printk(KERN_ERR "conegx: can't read GET_LED_PORT_0 Register\n");
+    } 
+    else 
+    {
+        Conegx->SetLedPort0Buffer = (char)(Val & 0xFF);
+        /* in case LEDs were read (wrong) during blinking sequence after 
+        startup of MSP */
+        /* set PWR LED */
+        Conegx->SetLedPort0Buffer |= BIT(IO_LED_2);
+        /* reset Relay-LEDs and TLS-LED */
+        Conegx->SetLedPort0Buffer &=  ~(  BIT(IO_LED_1) 
+                                        | BIT(IO_LED_3)
+                                        | BIT(IO_LED_4)
+                                        | BIT(IO_LED_5)
+                                        | BIT(IO_LED_6));
+        pr_debug("conegx: GET_LED_PORT_0: 0x%x\n", Val);
+    }
+
+    Ret = regmap_read(Conegx->regmap, GET_LED_PORT_1, &Val);
+    mdelay(I2C_DELAY);
+    if(Ret < 0) 
+    {
+        printk(KERN_ERR "conegx: can't read GET_LED_PORT_1 Register\n");
+    } 
+    else 
+    {
+        Conegx->SetLedPort1Buffer = (char)(Val & 0xFF);
+        pr_debug("conegx: GET_LED_PORT_1: 0x%x\n", Val);
+    }
+
+    /* Get Fw Version */
+    Ret = regmap_read(Conegx->regmap, FW_VERSION_MAJOR, &FwVersionMaj);
+    mdelay(I2C_DELAY);
+    if(Ret) 
+    {
+        printk(KERN_ERR "conegx: can't read FW_VERSION_MAJOR Register\n");
+        mutex_unlock(&Conegx->lock);
+        return Ret;
+    }
+    Ret = regmap_read(Conegx->regmap, FW_VERSION_MINOR_1, &FwVersionMin);
+    mdelay(I2C_DELAY);
+    if(Ret) 
+    {
+        printk(KERN_ERR "conegx: can't read FW_VERSION_MINOR_1 Register\n");
+        mutex_unlock(&Conegx->lock);
+        return Ret;
+    }
+    Ret = regmap_read(Conegx->regmap, FW_VERSION_MINOR_2, &FwVersionPatch);
+    mdelay(I2C_DELAY);
+    if(Ret) 
+    {
+        printk(KERN_ERR "conegx: can't read FW_VERSION_MINOR_2 Register\n");
+        mutex_unlock(&Conegx->lock);
+        return Ret;
+    }
+
+    /* Create Character Version of String */
+    sprintf(Conegx->FwVersion, "%d.%d.%d\n", FwVersionMaj, FwVersionMin,
+            FwVersionPatch);
+
+    pr_info("conegx: FirmwareVersion: %s", Conegx->FwVersion);
+
+    /* Get Button Lock Setting */
+    Ret = regmap_read(Conegx->regmap, GET_BUTTON_LOCK, &Val);
+    mdelay(I2C_DELAY);
+    if(Ret) 
+    {
+        printk(KERN_ERR "conegx: can't read GET_BUTTON_LOCK Register\n");
+        mutex_unlock(&Conegx->lock);
+        return Ret;
+    }
+    Conegx->TstButtonLock = (Val & 0x1);
+    Conegx->RstButtonLock = (Val & 0x10) >> 0x4;
+    pr_debug("conegx: RstButtonLock: %d", Conegx->RstButtonLock);
+    pr_debug("conegx: TstButtonLock: %d", Conegx->TstButtonLock);
+
+    mutex_unlock(&Conegx->lock);
+    return 0;
+}
+
+/**
+ * @brief Probe Function for the Conegx Device. Initializes the Module
+ */
+static int conegx_probe(struct i2c_client *client) {
+    int Ret;
+    int Err;
+    unsigned int Val;
+    unsigned long IrqFlags = IRQF_ONESHOT | IRQF_TRIGGER_RISING;
+
+    #ifdef CONEGX_TESTING
+    printk("conegx: Loaded in Testmode");
+    #endif // DEBUG
+    pr_info("conegx: Driver Version: %s",DRIVER_VERSION);
+    pr_debug("conegx: runnning probe for %s @ 0x%x", client->name, client->addr);
+
+    Conegx = devm_kzalloc(&client->dev, sizeof(*Conegx), GFP_KERNEL);
+    if(!Conegx)
+    {
+        return -ENOMEM;
+    }
+
+    Conegx->dev = &client->dev;
+    Conegx->addr = client->addr;
+    Conegx->irq = client->irq;
+
+    /* Initialize Regmap */
+    Conegx->regmap = devm_regmap_init_i2c(client, &ConegxRegmap);
+
+    Conegx->irq_chip.name = dev_name(Conegx->dev);
+
+    /* GPIO -----------------------------------------------------------------*/
+    Conegx->chip.label = client->name;
+    Conegx->chip.parent = &client->dev;
+    Conegx->chip.owner = THIS_MODULE;
+    Conegx->chip.get_direction = conegx_get_direction;
+    Conegx->chip.get = conegx_get_gpio;
+    Conegx->chip.set = set_gpio;
+    Conegx->chip.direction_input = conegx_direction_input;
+    Conegx->chip.direction_output = conegx_direction_output;
+    Conegx->chip.base = -1;
+    Conegx->chip.names = conegx_gpio_names;
+    Conegx->chip.ngpio = NUMBER_OF_CONEGX_GPIOS;
+    Conegx->chip.can_sleep = true;
+
+    Ret = devm_gpiochip_add_data(Conegx->dev, &Conegx->chip, Conegx);
+    if(Ret < 0) 
+    {
+        printk(KERN_ERR "conegx: can't add GPIO chip\n");
+    }
+
+    mutex_init(&Conegx->lock);
+
+    /* add Data to I2c and GPIO */
+    i2c_set_clientdata(client, Conegx);
+
+    /* IRQ -----------------------------------------------------------------*/
+
+    Ret = devm_request_threaded_irq(Conegx->chip.parent, Conegx->irq, NULL,
+                                    conegx_irq,
+                                    IrqFlags, "conegxirq", Conegx);
+
+    if(Ret != 0) 
+    {
+        dev_err(Conegx->dev, "conegx: unable to request IRQ#%d: %d\n",
+                Conegx->irq, Ret);
+        return Ret;
+    } 
+    else 
+    {
+        pr_debug("conegx: registered IRQ # %d\n",
+                Conegx->irq);
+    }
+
+    /* Setting up GPIO IRQ */
+    Err = gpiochip_irqchip_add_nested(&Conegx->chip,
+                                      &Conegx->irq_chip,
+                                      0,
+                                      handle_edge_irq,
+                                      IRQ_TYPE_NONE);
+
+    Conegx->chip.irq.threaded = true;
+
+    if(Err) 
+    {
+        dev_err(Conegx->dev,
+                "could not connect irqchip to gpiochip: %d\n", Err);
+        return Err;
+    }
+
+    gpiochip_set_nested_irqchip(&Conegx->chip,
+                                &Conegx->irq_chip,
+                                Conegx->irq);
+
+    /* Reading FW_VERSION Register to identify chip*/
+    mutex_lock(&Conegx->lock);
+    Ret = regmap_read(Conegx->regmap, DEVICE_DESCRIPTION, &Val);
+    mdelay(I2C_DELAY);
+    if(Ret < 0) 
+    {
+        printk(KERN_ERR "conegx: can't read DEVICE_DESCRIPTION Register\n");
+
+        reset_MSP430();
+    }
+    mutex_unlock(&Conegx->lock);
+    if(Val != 0x94) 
+    {
+        printk(KERN_ERR "conegx: DEVICE_DESCRIPTION wrong (!0x94): 0x%x\n", Val);
+        return 1;
+    }
+    else
+    {
+        pr_debug("conegx: valid DEVICE_DESCRIPTION (0x94)!\n");
+    }
+
+    /* read Register the first time */
+    Ret = conegx_getRegister();
+
+
+    if(Ret) 
+    {
+        printk(KERN_ERR "conegx: Error getting Device Data\n");
+    }
+
+    /* PROCFS ---------------------------------------------------------------*/
+    ProcfsParent = proc_mkdir("conegx", NULL);
+
+    if(ProcfsParent == NULL) 
+    {
+        printk(KERN_ERR "conegx: Error creating proc entry");
+    }
+
+    /*Creating Proc entry under "/proc/etx/" */
+    proc_create("fwversion", 0444, ProcfsParent, &proc_fops_fwversion);
+    proc_create("tstbuttonlock", 0666, ProcfsParent, &proc_fops_tstbuttonlock);
+    proc_create("rstbuttonlock", 0666, ProcfsParent, &proc_fops_rstbuttonlock);
+    proc_create("resetmsp", 0444, ProcfsParent, &proc_fops_resetmsp);
+
+    /* LEDS -----------------------------------------------------------------*/
+    setup_leds(client);
+
+    init_waitqueue_head(&IrSleepingQeue);
+
+    if(alloc_chrdev_region(&ConDevNr, 0, 1, "conegx_device") < 0)
+    {
+        return -EIO;
+    }
+    ConDriverObject = cdev_alloc(); /* Anmeldeobjekt reservieren */
+    if(ConDriverObject == NULL)
+    {
+        goto free_device_number;
+    }
+    ConDriverObject->owner = THIS_MODULE;
+    ConDriverObject->ops = &fops_devfile;
+    if(cdev_add(ConDriverObject, ConDevNr, 1))
+    {
+        goto free_cdev;
+    }
+    ConDevClass = class_create(THIS_MODULE, "conegx_class");
+    if(IS_ERR(ConDevClass)) 
+    {
+        pr_err("conegx_class: no udev support\n");
+        goto free_cdev;
+    }
+    ConDevice = device_create(ConDevClass, NULL, ConDevNr,
+                            NULL, "%s", "conegx");
+
+    if(IS_ERR(ConDevice))
+    {
+        goto free_class;
+    }
+    //dev_info(ConDevice, "mod_init");
+
+    /* Set OS Ready flag ----------------------------------------------------*/
+    Ret = regmap_write(Conegx->regmap, SET_OS_READY, 0x1);
+    mdelay(I2C_DELAY);
+    pr_info("conegx: Device Initialzed -> Setting OS_READY flag\n");
+    if (Ret) {
+        printk(KERN_ERR "conegx: Error writing to SET_OS_READY\n");
+
+        reset_MSP430();
+    }
+
+    return 0;
+
+free_class:
+    class_destroy(ConDevClass);
+free_cdev:
+    kobject_put(&ConDriverObject->kobj);
+free_device_number:
+    unregister_chrdev_region(ConDevNr, 1);
+    return -EIO;
+}
+
+/**
+ * @brief Remove Function called when the module is unloaded
+ */
+static int conegx_remove(struct i2c_client *client) 
+{
+    int Ret;
+    pr_info("conegx: Removing...-> disabling OS_READY flag\n");
+    Ret = regmap_write(Conegx->regmap, SET_OS_READY, 0x0);
+    mdelay(I2C_DELAY);
+    if(Ret) 
+    {
+        printk(KERN_ERR "conegx: Error writing to SET_OS_READY\n");
+        //reset_MSP430();
+    }
+    proc_remove(ProcfsParent);
+    unregister_leds(NR_OF_LEDS);
+    mutex_destroy(&Conegx->lock);
+    device_destroy(ConDevClass, ConDevNr);
+    class_destroy(ConDevClass);
+
+    return 0;
+}
+
+static int reset_MSP430(void)
+{
+    int rv;
+    int retries = 0;
+    int MAX_RETRIES = 5;
+
+    pr_info("conegx: Resetting MSP430...");
+
+    //mutex_lock(&Conegx->lock);
+    while(retries < MAX_RETRIES)
+    {
+        rv = gpio_request(RST_PIN, "MSP430_Reset");
+
+        if(rv != 0)
+        {
+            gpio_free(RST_PIN);
+            mdelay(100);
+            retries++;
+        }
+        else
+        {
+            rv = gpio_direction_output(RST_PIN, 1);
+            if(rv != 0)
+            {
+                gpio_free(RST_PIN);
+                mdelay(100);
+                retries++;
+            } 
+            else
+            {
+                retries = 0;
+                break;
+            }           
+        }
+    }
+    
+    if(retries != 0)
+    {
+        printk(KERN_ERR "conegx: Error requesting reset pin!");
+        printk(KERN_ERR "conegx: Resetting MSP430 failed!");
+        
+        return -1;
+    }
+
+    while(retries < MAX_RETRIES)
+    {
+        /* Toggle Reset Pin. */
+        gpio_set_value(RST_PIN, 0);
+
+        mdelay(100);
+
+        gpio_set_value(RST_PIN, 1);
+
+        mdelay(100);        
+        
+        /* Set Relays, LEDs will be updated by Status LED Controller. */
+        rv = regmap_write(Conegx->regmap, SET_RELAY_PORT, Conegx->SetRelayBuffer);
+        mdelay(I2C_DELAY);
+        if(rv < 0)
+        {
+            printk(KERN_ERR "conegx: Error setting relay port...");
+            retries++;
+            continue;
+        }
+
+        /* Set OS Ready flag ----------------------------------------------------*/
+        rv = regmap_write(Conegx->regmap, SET_OS_READY, 0x1);
+        mdelay(I2C_DELAY);              
+        if(rv == 0) 
+        {
+            pr_info("conegx: Reset successful, OS_READY flag set\n");
+            gpio_free(RST_PIN);
+            
+            return 0;
+        }
+        else
+        {
+            printk(KERN_ERR "conegx: Error resetting MSP...");
+        }
+
+        retries++;
+    }
+
+    gpio_free(RST_PIN);
+    printk(KERN_ERR "conegx: Resetting MSP430 failed!");
+    
+    return  -1;
+}
+
+/* I2c Divce Infos */
+static const struct i2c_device_id conegx_id_table[] = {
+    {"conegx", 1},
+    {/* sentinel */}};
+MODULE_DEVICE_TABLE(i2c, conegx_id_table);
+
+static const struct of_device_id conegx_of_match_table[] = {
+    {.compatible = "consolinno,conegx",
+     .data = (void *)1},
+    {/* sentinel */}};
+MODULE_DEVICE_TABLE(of, conegx_of_match_table);
+
+static struct i2c_driver conegx_driver = {
+    .driver = {
+        .name = "conegx",
+        .of_match_table = conegx_of_match_table,
+    },
+    .probe_new = conegx_probe,
+    .remove = conegx_remove,
+    .id_table = conegx_id_table,
+};
+module_i2c_driver(conegx_driver);
+
+MODULE_AUTHOR("Alexander Pietsch <a.pietsch@consolinno.de>");
+MODULE_DESCRIPTION("Driver for Consolinno Conegx");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpio/gpio-conegx.h b/drivers/gpio/gpio-conegx.h
new file mode 100644
index 000000000000..79a40420df7f
--- /dev/null
+++ b/drivers/gpio/gpio-conegx.h
@@ -0,0 +1,305 @@
+/**
+ * @file gpio-conegx.h
+ * @author A. Pietsch (a.pietsch@consolinno.de)
+ * @brief Driver for Consolinno Conegx Module
+ * @version 1.1.5
+ * @date 2021-06-22
+ * 
+ * @copyright: Copyrigth (c) 2023
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ * 
+ */
+
+
+#include <linux/gpio/driver.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/types.h>
+#include <linux/regmap.h>
+#include <linux/leds.h>
+
+#ifndef __CONEGX_DRIVER
+#define __CONEGX_DRIVER
+
+/* DIVER VERSION*/
+#define DRIVER_VERSION "1.1.5"
+
+/* Conegx Pins */
+/** 
+ * GPIO number = (bank - 1) * 32 + bit
+ * 
+ * Reset Pin is GPIO3_IO2 on the i.MX6
+ * 
+ * => RST_PIN = (3 - 1) * 32 + 2 = 66 
+ */
+#define RST_PIN 66
+
+#define I2C_DELAY 3 // 3 ms
+
+
+/* CONEGX REGISTERMAP */
+enum Conegx_Registermap {
+DEVICE_DESCRIPTION 	  ,
+FW_VERSION_MAJOR 	  ,
+FW_VERSION_MINOR_1 	  ,
+FW_VERSION_MINOR_2 	  ,
+SET_OS_READY 		  ,
+GET_INPUT_PORT 	      ,
+SET_RELAY_PORT 	      ,
+GET_RELAY_PORT 	      ,
+SET_LED_PORT_0 		  ,
+GET_LED_PORT_0 		  ,
+SET_LED_PORT_1 		  ,
+GET_LED_PORT_1 		  ,
+ALERT 				  ,
+SET_BUTTON_LOCK 	  ,
+GET_BUTTON_LOCK 	  ,
+
+NUMBER_OF_CONEGX_REGISTERS,
+};
+
+#define WRITE 1
+#define READ 0
+#define INPUT 1
+#define OUTPUT 0
+
+/* GPIO NUMBERS */
+enum GPIO_Numbers {
+IO_RELAY_1    ,
+IO_RELAY_2    ,
+IO_RELAY_3    ,
+IO_RELAY_4    ,
+IO_MRES_M2    ,
+IO_MRES_M1    ,
+IO_MRES_S2    ,
+IO_MRES_S1    ,
+IO_FLT_HBUS24 ,
+IO_FLT_HBUS   ,
+IO_RST_BUTTON ,
+IO_TST_BUTTON ,
+IO_PFI_1 	  ,
+IO_PFI_2 	  ,
+IO_PFI_3 	  ,
+IO_PFI_4 	  ,
+
+NUMBER_OF_CONEGX_GPIOS,
+};
+
+/* LED NUMBERS */
+enum LED_Numbers {
+IO_LED_1      ,
+IO_LED_2      ,
+IO_LED_3      ,
+IO_LED_4      ,
+IO_LED_5      ,
+IO_LED_6      ,
+IO_RGBLED_1_1 ,
+IO_RGBLED_1_2 ,
+IO_RGBLED_1_3 ,
+
+NUMBER_OF_CONEGX_LEDS,
+};
+
+
+/* ------------------------------IRQ------------------------------ */
+
+/* IRQ EDGES */
+#define FALLING_EDGE 0
+#define RISING_EDGE 1
+
+/* IRQ NUMBERS */
+enum IRQ_Numbers {
+POWER_FAILURE_INTERUPT 			    = 1,
+VOLTAGE_ALERT_INTERRUPT 			,
+VOLTAGE_NORMAL_INTERRUPT 			,
+POTENTIAL_FREE_INPUT_1_RISING_EDGE	= 14,
+POTENTIAL_FREE_INPUT_1_FALLING_EDGE	,
+POTENTIAL_FREE_INPUT_2_RISING_EDGE	,
+POTENTIAL_FREE_INPUT_2_FALLING_EDGE	,
+POTENTIAL_FREE_INPUT_3_RISING_EDGE	,
+POTENTIAL_FREE_INPUT_3_FALLING_EDGE	,
+POTENTIAL_FREE_INPUT_4_RISING_EDGE	,
+POTENTIAL_FREE_INPUT_4_FALLING_EDGE	,
+FLT_HBUS_RISING_EDGE				,
+FLT_HBUS_FALLING_EDGE				,
+FLT_HBUS24_RISING_EDGE				,
+FLT_HBUS24_FALLING_EDGE				,
+MRES_M1_RISING_EDGE					,
+MRES_M1_FALLING_EDGE				,
+MRES_M2_RISING_EDGE					,
+MRES_M2_FALLING_EDGE				,
+MRES_S1_RISING_EDGE					,
+MRES_S1_FALLING_EDGE				,
+MRES_S2_RISING_EDGE					,
+MRES_S2_FALLING_EDGE				,
+};
+/* LED */
+#define NR_OF_LEDS 9
+#define LED_FULL 255
+
+
+/**
+ * @brief conegx_gpio_irq_map [GpioNr, Edge]
+ * @description: maps IRQ Numbers to GPio Pins and Edges 
+ */
+const int conegx_gpio_irq_map[20][2] = {
+	{IO_PFI_1, RISING_EDGE},	//	PFI 1
+	{IO_PFI_1, FALLING_EDGE}, //	PFI 1
+	{IO_PFI_2, RISING_EDGE},	//	PFI 2
+	{IO_PFI_2, FALLING_EDGE}, //	PFI 2
+	{IO_PFI_3, RISING_EDGE},	//	PFI 3
+	{IO_PFI_3, FALLING_EDGE}, //	PFI 3
+	{IO_PFI_4, RISING_EDGE},	//	PFI 4
+	{IO_PFI_4, FALLING_EDGE}, //	PFI 4
+	{IO_FLT_HBUS, RISING_EDGE},	//	FLT_HBUS
+	{IO_FLT_HBUS, FALLING_EDGE},	//	FLT_HBUS
+	{IO_FLT_HBUS24, RISING_EDGE},	//	FLT_HBUS_24
+	{IO_FLT_HBUS24, FALLING_EDGE},	//	FLT_HBUS_24
+	{IO_MRES_M1, RISING_EDGE},	//	MRES_M1
+	{IO_MRES_M1, FALLING_EDGE},	//	MRES_M1
+	{IO_MRES_M2, RISING_EDGE},	//	MRES_M2
+	{IO_MRES_M2, FALLING_EDGE},	//	MRES_M2
+	{IO_MRES_S1, RISING_EDGE},	//	MRES_S1
+	{IO_MRES_S1, FALLING_EDGE},	//	MRES_S1
+	{IO_MRES_S2, RISING_EDGE},	//	MRES_S2
+	{IO_MRES_S2, FALLING_EDGE},	//	MRES_S2
+};
+
+/**
+ * @brief CONEGX REGISTER access 
+ * READ= read acces only
+ * WRITE=  write acces only
+ */
+const bool conegx_reg_access[NUMBER_OF_CONEGX_REGISTERS] = {
+	READ,  //	Get Device Description	
+	READ,  //	Get FW Version Major
+	READ,  //	Get FW Version Minor 1
+	READ,  //	Get FW Version Minor 2
+	WRITE, //	Set OS READy
+	READ,  //	Get Input Port
+	WRITE, //	Set Relay Port
+	READ,  //	Get Relay Port
+	WRITE, //	Set LED Port 0
+	READ,  //	Get LED Port 0
+	WRITE, //	Set LED Port 1
+	READ,  //	Get LED Port 1
+	READ,  //	Alert
+	WRITE, //	Set Button Lock
+	READ,  //	Get Button Lock	
+};
+
+const char *const conegx_gpio_names[NUMBER_OF_CONEGX_GPIOS] = {
+	"S_1",
+	"S_2",
+	"W_3",
+	"W_4",
+	"MRES_M2",
+	"MRES_M1",
+	"MRES_S2",
+	"MRES_S1",
+	"FLT_HBUS24",
+	"FLT_HBUS",
+	"RST_Butt",
+	"TST_Butt",
+	"SwitchIN_1",
+	"SwitchIN_2",
+	"SwitchIN_3",
+	"SwitchIN_4",
+};
+
+const char *const conegx_led_names[NUMBER_OF_CONEGX_LEDS] = {
+	"CON:LED1",
+	"CON:LED2",
+	"CON:LED3",
+	"CON:LED4",
+	"CON:LED5",
+	"CON:LED6",
+	"CON:RGBLED1.1",
+	"CON:RGBLED1.2",
+	"CON:RGBLED1.3",
+};
+
+const int conegx_directions[NUMBER_OF_CONEGX_GPIOS] = {
+	OUTPUT,	// IO_RELAY_1   
+	OUTPUT,	// IO_RELAY_2   
+	OUTPUT,	// IO_RELAY_3   
+	OUTPUT,	// IO_RELAY_4   
+	INPUT,	// IO_MRES_M2   
+	INPUT,	// IO_MRES_M1   
+	INPUT,	// IO_MRES_S2   
+	INPUT,	// IO_MRES_S1   
+	INPUT,	// IO_FLT_HBUS24
+	INPUT,	// IO_FLT_HBUS  
+	INPUT,	// IO_RST_BUTTON
+	INPUT,	// IO_TST_BUTTON
+	INPUT,	// IO_PFI_1
+	INPUT,	// IO_PFI_2
+	INPUT,	// IO_PFI_3
+	INPUT	// IO_PFI_4
+};
+
+/**
+ * @brief Struct For Conegx LEDs
+ * 
+ */
+struct conegx_led {
+	u8 id;
+	bool active;
+	struct i2c_client *client;
+	const char *name;
+	const char *default_trigger;
+	struct led_classdev ldev;
+	struct work_struct work;
+	u32 type;
+	unsigned int led_no;
+
+};
+
+/**
+ * @brief Struct For conegx Data
+ * 
+ */
+struct conegx
+{
+	struct gpio_chip chip;
+	struct irq_chip irq_chip;
+	struct mutex lock;
+	struct device *dev;
+	struct regmap *regmap;
+	struct conegx_led leds[NR_OF_LEDS];
+	int irq;
+	__u8 out;
+	__u8 addr;
+
+	/* Register Buffers */
+	__u8 SetRelayBuffer;
+	__u8 SetHbusBuffer;
+	__u8 SetHbusDirectionBuffer;
+	__u8 SetLedPort0Buffer;
+	__u8 SetLedPort1Buffer;
+
+	/* Device Status Info */
+	uint LastInterruptNr;
+	int PowerFail;
+	int VoltageRange;
+	char FwVersion[12];
+	int RelayDefaultSetting;
+	int TstButtonLock;
+	int RstButtonLock;
+	int IRQDeviceFileEnabled;
+	int IRQVoltageRangeEnabled;
+	int IRQPowerFailEnabled;
+};
+
+
+#endif // CONEGX_DRIVER
diff --git a/drivers/i2c/busses/i2c-imx.c b/drivers/i2c/busses/i2c-imx.c
index 9d3f42fd6352..474829173734 100644
--- a/drivers/i2c/busses/i2c-imx.c
+++ b/drivers/i2c/busses/i2c-imx.c
@@ -34,6 +34,7 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
+#include <linux/iopoll.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/of.h>
@@ -427,7 +428,7 @@ static void i2c_imx_clear_irq(struct imx_i2c_struct *i2c_imx, unsigned int bits)
 	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2SR);
 }
 
-static int i2c_imx_bus_busy(struct imx_i2c_struct *i2c_imx, int for_busy)
+static int i2c_imx_bus_busy(struct imx_i2c_struct *i2c_imx, int for_busy, bool atomic)
 {
 	unsigned long orig_jiffies = jiffies;
 	unsigned int temp;
@@ -456,15 +457,37 @@ static int i2c_imx_bus_busy(struct imx_i2c_struct *i2c_imx, int for_busy)
 				"<%s> I2C bus is busy\n", __func__);
 			return -ETIMEDOUT;
 		}
-		schedule();
+		if (atomic)
+			udelay(100);
+		else
+			schedule();
 	}
 
 	return 0;
 }
 
-static int i2c_imx_trx_complete(struct imx_i2c_struct *i2c_imx)
+static int i2c_imx_trx_complete(struct imx_i2c_struct *i2c_imx, bool atomic)
 {
-	wait_event_timeout(i2c_imx->queue, i2c_imx->i2csr & I2SR_IIF, HZ / 10);
+	if (atomic) {
+		void __iomem *addr = i2c_imx->base + (IMX_I2C_I2SR << i2c_imx->hwdata->regshift);
+		unsigned int regval;
+
+		/*
+		 * The formula for the poll timeout is documented in the RM
+		 * Rev.5 on page 1878:
+		 *     T_min = 10/F_scl
+		 * Set the value hard as it is done for the non-atomic use-case.
+		 * Use 10 kHz for the calculation since this is the minimum
+		 * allowed SMBus frequency. Also add an offset of 100us since it
+		 * turned out that the I2SR_IIF bit isn't set correctly within
+		 * the minimum timeout in polling mode.
+		 */
+		readb_poll_timeout_atomic(addr, regval, regval & I2SR_IIF, 5, 1000 + 100);
+		i2c_imx->i2csr = regval;
+		imx_i2c_write_reg(0, i2c_imx, IMX_I2C_I2SR);
+	} else {
+		wait_event_timeout(i2c_imx->queue, i2c_imx->i2csr & I2SR_IIF, HZ / 10);
+	}
 
 	if (unlikely(!(i2c_imx->i2csr & I2SR_IIF))) {
 		dev_dbg(&i2c_imx->adapter.dev, "<%s> Timeout\n", __func__);
@@ -552,7 +575,7 @@ static int i2c_imx_clk_notifier_call(struct notifier_block *nb,
 	return NOTIFY_OK;
 }
 
-static int i2c_imx_start(struct imx_i2c_struct *i2c_imx)
+static int i2c_imx_start(struct imx_i2c_struct *i2c_imx, bool atomic)
 {
 	unsigned int temp = 0;
 	int result;
@@ -565,23 +588,29 @@ static int i2c_imx_start(struct imx_i2c_struct *i2c_imx)
 	imx_i2c_write_reg(i2c_imx->hwdata->i2cr_ien_opcode, i2c_imx, IMX_I2C_I2CR);
 
 	/* Wait controller to be stable */
-	usleep_range(50, 150);
+	if (atomic)
+		udelay(50);
+	else
+		usleep_range(50, 150);
 
 	/* Start I2C transaction */
 	temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);
 	temp |= I2CR_MSTA;
 	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
-	result = i2c_imx_bus_busy(i2c_imx, 1);
+	result = i2c_imx_bus_busy(i2c_imx, 1, atomic);
 	if (result)
 		return result;
 
 	temp |= I2CR_IIEN | I2CR_MTX | I2CR_TXAK;
+	if (atomic)
+		temp &= ~I2CR_IIEN; /* Disable interrupt */
+
 	temp &= ~I2CR_DMAEN;
 	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
 	return result;
 }
 
-static void i2c_imx_stop(struct imx_i2c_struct *i2c_imx)
+static void i2c_imx_stop(struct imx_i2c_struct *i2c_imx, bool atomic)
 {
 	unsigned int temp = 0;
 
@@ -605,7 +634,7 @@ static void i2c_imx_stop(struct imx_i2c_struct *i2c_imx)
 	}
 
 	if (!i2c_imx->stopped)
-		i2c_imx_bus_busy(i2c_imx, 0);
+		i2c_imx_bus_busy(i2c_imx, 0, atomic);
 
 	/* Disable I2C controller */
 	temp = i2c_imx->hwdata->i2cr_ien_opcode ^ I2CR_IEN,
@@ -684,7 +713,7 @@ static int i2c_imx_dma_write(struct imx_i2c_struct *i2c_imx,
 	/* The last data byte must be transferred by the CPU. */
 	imx_i2c_write_reg(msgs->buf[msgs->len-1],
 				i2c_imx, IMX_I2C_I2DR);
-	result = i2c_imx_trx_complete(i2c_imx);
+	result = i2c_imx_trx_complete(i2c_imx, false);
 	if (result)
 		return result;
 
@@ -743,7 +772,7 @@ static int i2c_imx_dma_read(struct imx_i2c_struct *i2c_imx,
 
 	msgs->buf[msgs->len-2] = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);
 	/* read n byte data */
-	result = i2c_imx_trx_complete(i2c_imx);
+	result = i2c_imx_trx_complete(i2c_imx, false);
 	if (result)
 		return result;
 
@@ -759,7 +788,7 @@ static int i2c_imx_dma_read(struct imx_i2c_struct *i2c_imx,
 		temp &= ~(I2CR_MSTA | I2CR_MTX);
 		imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
 		if (!i2c_imx->stopped)
-			i2c_imx_bus_busy(i2c_imx, 0);
+			i2c_imx_bus_busy(i2c_imx, 0, false);
 	} else {
 		/*
 		 * For i2c master receiver repeat restart operation like:
@@ -777,7 +806,8 @@ static int i2c_imx_dma_read(struct imx_i2c_struct *i2c_imx,
 	return 0;
 }
 
-static int i2c_imx_write(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs)
+static int i2c_imx_write(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs,
+			 bool atomic)
 {
 	int i, result;
 
@@ -786,7 +816,7 @@ static int i2c_imx_write(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs)
 
 	/* write slave address */
 	imx_i2c_write_reg(i2c_8bit_addr_from_msg(msgs), i2c_imx, IMX_I2C_I2DR);
-	result = i2c_imx_trx_complete(i2c_imx);
+	result = i2c_imx_trx_complete(i2c_imx, atomic);
 	if (result)
 		return result;
 	result = i2c_imx_acked(i2c_imx);
@@ -800,7 +830,7 @@ static int i2c_imx_write(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs)
 			"<%s> write byte: B%d=0x%X\n",
 			__func__, i, msgs->buf[i]);
 		imx_i2c_write_reg(msgs->buf[i], i2c_imx, IMX_I2C_I2DR);
-		result = i2c_imx_trx_complete(i2c_imx);
+		result = i2c_imx_trx_complete(i2c_imx, atomic);
 		if (result)
 			return result;
 		result = i2c_imx_acked(i2c_imx);
@@ -810,7 +840,8 @@ static int i2c_imx_write(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs)
 	return 0;
 }
 
-static int i2c_imx_read(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs, bool is_lastmsg)
+static int i2c_imx_read(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs,
+			bool is_lastmsg, bool atomic)
 {
 	int i, result;
 	unsigned int temp;
@@ -823,7 +854,7 @@ static int i2c_imx_read(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs, bo
 
 	/* write slave address */
 	imx_i2c_write_reg(i2c_8bit_addr_from_msg(msgs), i2c_imx, IMX_I2C_I2DR);
-	result = i2c_imx_trx_complete(i2c_imx);
+	result = i2c_imx_trx_complete(i2c_imx, atomic);
 	if (result)
 		return result;
 	result = i2c_imx_acked(i2c_imx);
@@ -856,7 +887,7 @@ static int i2c_imx_read(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs, bo
 	for (i = 0; i < msgs->len; i++) {
 		u8 len = 0;
 
-		result = i2c_imx_trx_complete(i2c_imx);
+		result = i2c_imx_trx_complete(i2c_imx, atomic);
 		if (result)
 			return result;
 		/*
@@ -887,7 +918,7 @@ static int i2c_imx_read(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs, bo
 				temp &= ~(I2CR_MSTA | I2CR_MTX);
 				imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
 				if (!i2c_imx->stopped)
-					i2c_imx_bus_busy(i2c_imx, 0);
+					i2c_imx_bus_busy(i2c_imx, 0, atomic);
 			} else {
 				/*
 				 * For i2c master receiver repeat restart operation like:
@@ -918,8 +949,8 @@ static int i2c_imx_read(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs, bo
 	return 0;
 }
 
-static int i2c_imx_xfer(struct i2c_adapter *adapter,
-						struct i2c_msg *msgs, int num)
+static int i2c_imx_xfer_common(struct i2c_adapter *adapter,
+			       struct i2c_msg *msgs, int num, bool atomic)
 {
 	unsigned int i, temp;
 	int result;
@@ -928,16 +959,16 @@ static int i2c_imx_xfer(struct i2c_adapter *adapter,
 
 	dev_dbg(&i2c_imx->adapter.dev, "<%s>\n", __func__);
 
-	result = pm_runtime_get_sync(i2c_imx->adapter.dev.parent);
-	if (result < 0)
-		goto out;
-
 	/* Start I2C transfer */
-	result = i2c_imx_start(i2c_imx);
+	result = i2c_imx_start(i2c_imx, atomic);
 	if (result) {
-		if (i2c_imx->adapter.bus_recovery_info) {
+		/*
+		 * Bus recovery uses gpiod_get_value_cansleep() which is not
+		 * allowed within atomic context.
+		 */
+		if (!atomic && i2c_imx->adapter.bus_recovery_info) {
 			i2c_recover_bus(&i2c_imx->adapter);
-			result = i2c_imx_start(i2c_imx);
+			result = i2c_imx_start(i2c_imx, atomic);
 		}
 	}
 
@@ -955,7 +986,7 @@ static int i2c_imx_xfer(struct i2c_adapter *adapter,
 			temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);
 			temp |= I2CR_RSTA;
 			imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
-			result = i2c_imx_bus_busy(i2c_imx, 1);
+			result = i2c_imx_bus_busy(i2c_imx, 1, atomic);
 			if (result)
 				goto fail0;
 		}
@@ -979,13 +1010,14 @@ static int i2c_imx_xfer(struct i2c_adapter *adapter,
 			(temp & I2SR_SRW ? 1 : 0), (temp & I2SR_IIF ? 1 : 0),
 			(temp & I2SR_RXAK ? 1 : 0));
 #endif
-		if (msgs[i].flags & I2C_M_RD)
-			result = i2c_imx_read(i2c_imx, &msgs[i], is_lastmsg);
-		else {
-			if (i2c_imx->dma && msgs[i].len >= DMA_THRESHOLD)
+		if (msgs[i].flags & I2C_M_RD) {
+			result = i2c_imx_read(i2c_imx, &msgs[i], is_lastmsg, atomic);
+		} else {
+			if (!atomic &&
+			    i2c_imx->dma && msgs[i].len >= DMA_THRESHOLD)
 				result = i2c_imx_dma_write(i2c_imx, &msgs[i]);
 			else
-				result = i2c_imx_write(i2c_imx, &msgs[i]);
+				result = i2c_imx_write(i2c_imx, &msgs[i], atomic);
 		}
 		if (result)
 			goto fail0;
@@ -993,18 +1025,49 @@ static int i2c_imx_xfer(struct i2c_adapter *adapter,
 
 fail0:
 	/* Stop I2C transfer */
-	i2c_imx_stop(i2c_imx);
-
-	pm_runtime_mark_last_busy(i2c_imx->adapter.dev.parent);
-	pm_runtime_put_autosuspend(i2c_imx->adapter.dev.parent);
+	i2c_imx_stop(i2c_imx, atomic);
 
-out:
 	dev_dbg(&i2c_imx->adapter.dev, "<%s> exit with: %s: %d\n", __func__,
 		(result < 0) ? "error" : "success msg",
 			(result < 0) ? result : num);
 	return (result < 0) ? result : num;
 }
 
+static int i2c_imx_xfer(struct i2c_adapter *adapter,
+			struct i2c_msg *msgs, int num)
+{
+	struct imx_i2c_struct *i2c_imx = i2c_get_adapdata(adapter);
+	int result;
+
+	result = pm_runtime_get_sync(i2c_imx->adapter.dev.parent);
+	if (result < 0)
+		return result;
+
+	result = i2c_imx_xfer_common(adapter, msgs, num, false);
+
+	pm_runtime_mark_last_busy(i2c_imx->adapter.dev.parent);
+	pm_runtime_put_autosuspend(i2c_imx->adapter.dev.parent);
+
+	return result;
+}
+
+static int i2c_imx_xfer_atomic(struct i2c_adapter *adapter,
+			       struct i2c_msg *msgs, int num)
+{
+	struct imx_i2c_struct *i2c_imx = i2c_get_adapdata(adapter);
+	int result;
+
+	result = clk_enable(i2c_imx->clk);
+	if (result)
+		return result;
+
+	result = i2c_imx_xfer_common(adapter, msgs, num, true);
+
+	clk_disable(i2c_imx->clk);
+
+	return result;
+}
+
 static void i2c_imx_prepare_recovery(struct i2c_adapter *adap)
 {
 	struct imx_i2c_struct *i2c_imx;
@@ -1077,8 +1140,9 @@ static u32 i2c_imx_func(struct i2c_adapter *adapter)
 }
 
 static const struct i2c_algorithm i2c_imx_algo = {
-	.master_xfer	= i2c_imx_xfer,
-	.functionality	= i2c_imx_func,
+	.master_xfer = i2c_imx_xfer,
+	.master_xfer_atomic = i2c_imx_xfer_atomic,
+	.functionality = i2c_imx_func,
 };
 
 static int i2c_imx_probe(struct platform_device *pdev)
diff --git a/drivers/iio/adc/vf610_adc.c b/drivers/iio/adc/vf610_adc.c
index 0d29fe974d70..204423e0462a 100644
--- a/drivers/iio/adc/vf610_adc.c
+++ b/drivers/iio/adc/vf610_adc.c
@@ -2,7 +2,7 @@
 /*
  * Freescale Vybrid vf610 ADC driver
  *
- * Copyright 2013 Freescale Semiconductor, Inc.
+ * Copyright 2013-2015 Freescale Semiconductor, Inc.
  */
 
 #include <linux/module.h>
@@ -809,6 +809,7 @@ static int vf610_adc_probe(struct platform_device *pdev)
 	struct resource *mem;
 	int irq;
 	int ret;
+	u32 channels;
 
 	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(struct vf610_adc));
 	if (!indio_dev) {
@@ -865,13 +866,18 @@ static int vf610_adc_probe(struct platform_device *pdev)
 
 	init_completion(&info->completion);
 
+	ret  = of_property_read_u32(pdev->dev.of_node,
+					"num-channels", &channels);
+	if (ret)
+		channels = ARRAY_SIZE(vf610_adc_iio_channels);
+
 	indio_dev->name = dev_name(&pdev->dev);
 	indio_dev->dev.parent = &pdev->dev;
 	indio_dev->dev.of_node = pdev->dev.of_node;
 	indio_dev->info = &vf610_adc_iio_info;
 	indio_dev->modes = INDIO_DIRECT_MODE;
 	indio_dev->channels = vf610_adc_iio_channels;
-	indio_dev->num_channels = ARRAY_SIZE(vf610_adc_iio_channels);
+	indio_dev->num_channels = (int)channels;
 
 	ret = clk_prepare_enable(info->clk);
 	if (ret) {
diff --git a/drivers/input/touchscreen/stmpe-ts.c b/drivers/input/touchscreen/stmpe-ts.c
index 7e16fcfe3b95..cd747725589b 100644
--- a/drivers/input/touchscreen/stmpe-ts.c
+++ b/drivers/input/touchscreen/stmpe-ts.c
@@ -14,6 +14,7 @@
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/input.h>
+#include <linux/input/touchscreen.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/i2c.h>
@@ -72,6 +73,7 @@ struct stmpe_touch {
 	struct input_dev *idev;
 	struct delayed_work work;
 	struct device *dev;
+	struct touchscreen_properties prop;
 	u8 ave_ctrl;
 	u8 touch_det_delay;
 	u8 settling;
@@ -150,8 +152,7 @@ static irqreturn_t stmpe_ts_handler(int irq, void *data)
 	y = ((data_set[1] & 0xf) << 8) | data_set[2];
 	z = data_set[3];
 
-	input_report_abs(ts->idev, ABS_X, x);
-	input_report_abs(ts->idev, ABS_Y, y);
+	touchscreen_report_pos(ts->idev, &ts->prop, x, y, false);
 	input_report_abs(ts->idev, ABS_PRESSURE, z);
 	input_report_key(ts->idev, BTN_TOUCH, 1);
 	input_sync(ts->idev);
@@ -337,6 +338,8 @@ static int stmpe_input_probe(struct platform_device *pdev)
 	input_set_abs_params(idev, ABS_Y, 0, XY_MASK, 0, 0);
 	input_set_abs_params(idev, ABS_PRESSURE, 0x0, 0xff, 0, 0);
 
+	touchscreen_parse_properties(idev, false, &ts->prop);
+
 	error = input_register_device(idev);
 	if (error) {
 		dev_err(&pdev->dev, "Could not register input device\n");
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index fcffcc31d168..528b495593ff 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -880,6 +880,7 @@ config VIDEO_MT9P031
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
 	depends on MEDIA_CAMERA_SUPPORT
 	select VIDEO_APTINA_PLL
+	select V4L2_FWNODE
 	help
 	  This is a Video4Linux2 sensor driver for the Aptina
 	  (Micron) mt9p031 5 Mpixel camera.
diff --git a/drivers/media/i2c/mt9p031.c b/drivers/media/i2c/mt9p031.c
index 18440c5104ad..bbdb5f1563aa 100644
--- a/drivers/media/i2c/mt9p031.c
+++ b/drivers/media/i2c/mt9p031.c
@@ -27,6 +27,7 @@
 #include <media/v4l2-async.h>
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
 #include <media/v4l2-subdev.h>
 
 #include "aptina-pll.h"
@@ -118,6 +119,18 @@ enum mt9p031_model {
 	MT9P031_MODEL_MONOCHROME,
 };
 
+static const u32 mt9p031_color_fmts[] = {
+	MEDIA_BUS_FMT_SGRBG8_1X8,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SGRBG12_1X12,
+};
+
+static const u32 mt9p031_monochrome_fmts[] = {
+	MEDIA_BUS_FMT_Y8_1X8,
+	MEDIA_BUS_FMT_Y10_1X10,
+	MEDIA_BUS_FMT_Y12_1X12,
+};
+
 struct mt9p031 {
 	struct v4l2_subdev subdev;
 	struct media_pad pad;
@@ -140,6 +153,9 @@ struct mt9p031 {
 	struct v4l2_ctrl *blc_auto;
 	struct v4l2_ctrl *blc_offset;
 
+	const u32 *fmts;
+	int num_fmts;
+
 	/* Registers cache */
 	u16 output_control;
 	u16 mode2;
@@ -150,6 +166,17 @@ static struct mt9p031 *to_mt9p031(struct v4l2_subdev *sd)
 	return container_of(sd, struct mt9p031, subdev);
 }
 
+static const u32 mt9p031_find_datafmt(struct mt9p031 *mt9p031, u32 code)
+{
+	int i;
+
+	for (i=0; i < mt9p031->num_fmts; i++)
+		if (mt9p031->fmts[i] == code)
+			return mt9p031->fmts[i];
+
+	return mt9p031->fmts[mt9p031->num_fmts-1];
+}
+
 static int mt9p031_read(struct i2c_client *client, u8 reg)
 {
 	return i2c_smbus_read_word_swapped(client, reg);
@@ -231,6 +258,7 @@ static int mt9p031_clk_setup(struct mt9p031 *mt9p031)
 
 	struct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);
 	struct mt9p031_platform_data *pdata = mt9p031->pdata;
+	unsigned long ext_freq;
 	int ret;
 
 	mt9p031->clk = devm_clk_get(&client->dev, NULL);
@@ -241,13 +269,15 @@ static int mt9p031_clk_setup(struct mt9p031 *mt9p031)
 	if (ret < 0)
 		return ret;
 
+	ext_freq = clk_get_rate(mt9p031->clk);
+
 	/* If the external clock frequency is out of bounds for the PLL use the
 	 * pixel clock divider only and disable the PLL.
 	 */
-	if (pdata->ext_freq > limits.ext_clock_max) {
+	if (ext_freq > limits.ext_clock_max) {
 		unsigned int div;
 
-		div = DIV_ROUND_UP(pdata->ext_freq, pdata->target_freq);
+		div = DIV_ROUND_UP(ext_freq, pdata->target_freq);
 		div = roundup_pow_of_two(div) / 2;
 
 		mt9p031->clk_div = min_t(unsigned int, div, 64);
@@ -256,7 +286,7 @@ static int mt9p031_clk_setup(struct mt9p031 *mt9p031)
 		return 0;
 	}
 
-	mt9p031->pll.ext_clock = pdata->ext_freq;
+	mt9p031->pll.ext_clock = ext_freq;
 	mt9p031->pll.pix_clock = pdata->target_freq;
 	mt9p031->use_pll = true;
 
@@ -372,6 +402,14 @@ static int __mt9p031_set_power(struct mt9p031 *mt9p031, bool on)
 		return ret;
 	}
 
+	/* Configure the pixel clock polarity */
+	if (mt9p031->pdata && mt9p031->pdata->pixclk_pol) {
+		ret = mt9p031_write(client, MT9P031_PIXEL_CLOCK_CONTROL,
+				MT9P031_PIXEL_CLOCK_INVERT);
+		if (ret < 0)
+			return ret;
+	}
+
 	return v4l2_ctrl_handler_setup(&mt9p031->ctrls);
 }
 
@@ -502,10 +540,11 @@ static int mt9p031_enum_mbus_code(struct v4l2_subdev *subdev,
 {
 	struct mt9p031 *mt9p031 = to_mt9p031(subdev);
 
-	if (code->pad || code->index)
+	if (code->pad || code->index >= mt9p031->num_fmts)
 		return -EINVAL;
 
-	code->code = mt9p031->format.code;
+	code->code = mt9p031->fmts[code->index];
+
 	return 0;
 }
 
@@ -599,6 +638,8 @@ static int mt9p031_set_format(struct v4l2_subdev *subdev,
 	__format->width = __crop->width / hratio;
 	__format->height = __crop->height / vratio;
 
+	__format->code = mt9p031_find_datafmt(mt9p031, format->format.code);
+
 	format->format = *__format;
 
 	return 0;
@@ -697,6 +738,30 @@ static int mt9p031_restore_blc(struct mt9p031 *mt9p031)
 	return 0;
 }
 
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int mt9p031_g_register(struct v4l2_subdev *sd,
+			      struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = mt9p031_read(client, reg->reg);
+	if (ret < 0)
+		return ret;
+
+	reg->val = ret;
+	return 0;
+}
+
+static int mt9p031_s_register(struct v4l2_subdev *sd,
+			      struct v4l2_dbg_register const *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return mt9p031_write(client, reg->reg, reg->val);
+}
+#endif
+
 static int mt9p031_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct mt9p031 *mt9p031 =
@@ -977,10 +1042,7 @@ static int mt9p031_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
 
 	format = v4l2_subdev_get_try_format(subdev, fh->pad, 0);
 
-	if (mt9p031->model == MT9P031_MODEL_MONOCHROME)
-		format->code = MEDIA_BUS_FMT_Y12_1X12;
-	else
-		format->code = MEDIA_BUS_FMT_SGRBG12_1X12;
+	format->code = mt9p031_find_datafmt(mt9p031, 0);
 
 	format->width = MT9P031_WINDOW_WIDTH_DEF;
 	format->height = MT9P031_WINDOW_HEIGHT_DEF;
@@ -997,6 +1059,10 @@ static int mt9p031_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
 
 static const struct v4l2_subdev_core_ops mt9p031_subdev_core_ops = {
 	.s_power        = mt9p031_set_power,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.s_register	= mt9p031_s_register,
+	.g_register	= mt9p031_g_register,
+#endif
 };
 
 static const struct v4l2_subdev_video_ops mt9p031_subdev_video_ops = {
@@ -1031,7 +1097,8 @@ static const struct v4l2_subdev_internal_ops mt9p031_subdev_internal_ops = {
 static struct mt9p031_platform_data *
 mt9p031_get_pdata(struct i2c_client *client)
 {
-	struct mt9p031_platform_data *pdata;
+	struct mt9p031_platform_data *pdata = NULL;
+	struct v4l2_fwnode_endpoint endpoint;
 	struct device_node *np;
 
 	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
@@ -1041,6 +1108,10 @@ mt9p031_get_pdata(struct i2c_client *client)
 	if (!np)
 		return NULL;
 
+	endpoint.bus_type = V4L2_MBUS_UNKNOWN;
+	if (v4l2_fwnode_endpoint_parse(of_fwnode_handle(np), &endpoint) < 0)
+		goto done;
+
 	pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
 	if (!pdata)
 		goto done;
@@ -1048,6 +1119,9 @@ mt9p031_get_pdata(struct i2c_client *client)
 	of_property_read_u32(np, "input-clock-frequency", &pdata->ext_freq);
 	of_property_read_u32(np, "pixel-clock-frequency", &pdata->target_freq);
 
+	pdata->pixclk_pol = !!(endpoint.bus.parallel.flags &
+			       V4L2_MBUS_PCLK_SAMPLE_RISING);
+
 done:
 	of_node_put(np);
 	return pdata;
@@ -1147,10 +1221,14 @@ static int mt9p031_probe(struct i2c_client *client,
 	mt9p031->crop.left = MT9P031_COLUMN_START_DEF;
 	mt9p031->crop.top = MT9P031_ROW_START_DEF;
 
-	if (mt9p031->model == MT9P031_MODEL_MONOCHROME)
-		mt9p031->format.code = MEDIA_BUS_FMT_Y12_1X12;
-	else
-		mt9p031->format.code = MEDIA_BUS_FMT_SGRBG12_1X12;
+	if (mt9p031->model == MT9P031_MODEL_MONOCHROME) {
+		mt9p031->fmts = mt9p031_monochrome_fmts;
+		mt9p031->num_fmts = ARRAY_SIZE(mt9p031_monochrome_fmts);
+	} else {
+		mt9p031->fmts = mt9p031_color_fmts;
+		mt9p031->num_fmts = ARRAY_SIZE(mt9p031_color_fmts);
+	}
+	mt9p031->format.code = mt9p031_find_datafmt(mt9p031, 0);
 
 	mt9p031->format.width = MT9P031_WINDOW_WIDTH_DEF;
 	mt9p031->format.height = MT9P031_WINDOW_HEIGHT_DEF;
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 32801639e0be..cf383c65ee3b 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -432,6 +432,20 @@ int mmc_of_parse_voltage(struct device_node *np, u32 *mask)
 }
 EXPORT_SYMBOL(mmc_of_parse_voltage);
 
+/**
+ * mmc_first_nonreserved_index() - get the first index that is not reserved
+ */
+static int mmc_first_nonreserved_index(void)
+{
+	int max;
+
+	max = of_alias_get_highest_id("mmc");
+	if (max < 0)
+		return 0;
+
+	return max + 1;
+}
+
 /**
  *	mmc_alloc_host - initialise the per-host structure.
  *	@extra: sizeof private data structure
@@ -443,6 +457,7 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 {
 	int err;
 	struct mmc_host *host;
+	int alias_id, min_idx, max_idx;
 
 	host = kzalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);
 	if (!host)
@@ -451,7 +466,16 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 	/* scanning will be enabled when we're ready */
 	host->rescan_disable = 1;
 
-	err = ida_simple_get(&mmc_host_ida, 0, 0, GFP_KERNEL);
+	alias_id = of_alias_get_id(dev->of_node, "mmc");
+	if (alias_id >= 0) {
+		min_idx = alias_id;
+		max_idx = alias_id + 1;
+	} else {
+		min_idx = mmc_first_nonreserved_index();
+		max_idx = 0;
+	}
+
+	err = ida_simple_get(&mmc_host_ida, min_idx, max_idx, GFP_KERNEL);
 	if (err < 0) {
 		kfree(host);
 		return NULL;
diff --git a/drivers/mtd/nand/raw/gpmi-nand/gpmi-nand.c b/drivers/mtd/nand/raw/gpmi-nand/gpmi-nand.c
index b806a762d079..966d16a0515c 100644
--- a/drivers/mtd/nand/raw/gpmi-nand/gpmi-nand.c
+++ b/drivers/mtd/nand/raw/gpmi-nand/gpmi-nand.c
@@ -122,19 +122,26 @@ static int __gpmi_enable_clk(struct gpmi_nand_data *this, bool v)
 	int ret;
 	int i;
 
-	for (i = 0; i < GPMI_CLK_MAX; i++) {
-		clk = this->resources.clock[i];
-		if (!clk)
-			break;
+	if (v) {
+		for (i = 0; i < GPMI_CLK_MAX; i++) {
+			clk = this->resources.clock[i];
+			if (!clk)
+				break;
 
-		if (v) {
 			ret = clk_prepare_enable(clk);
 			if (ret)
 				goto err_clk;
-		} else {
+		}
+	} else {
+		for (i = GPMI_CLK_MAX; i > 0; i--) {
+			clk = this->resources.clock[i - 1];
+			if (!clk)
+				continue;
+
 			clk_disable_unprepare(clk);
 		}
 	}
+
 	return 0;
 
 err_clk:
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index e1b8c58c4d6b..05a926765fea 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -3525,6 +3525,7 @@ fec_probe(struct platform_device *pdev)
 	char irq_name[8];
 	int irq_cnt;
 	struct fec_devinfo *dev_info;
+	int eth_id;
 
 	fec_enet_get_queue_num(pdev, &num_tx_qs, &num_rx_qs);
 
@@ -3711,6 +3712,11 @@ fec_probe(struct platform_device *pdev)
 	fec_enet_clk_enable(ndev, false);
 	pinctrl_pm_select_sleep_state(&pdev->dev);
 
+	eth_id = of_alias_get_id(pdev->dev.of_node, "ethernet");
+
+	if (eth_id >= 0)
+		sprintf(ndev->name, "eth%d", eth_id);
+
 	ret = register_netdev(ndev);
 	if (ret)
 		goto failed_register;
diff --git a/drivers/nfc/Kconfig b/drivers/nfc/Kconfig
index 75c65d339018..f40ca1cd0542 100644
--- a/drivers/nfc/Kconfig
+++ b/drivers/nfc/Kconfig
@@ -49,6 +49,16 @@ config NFC_PORT100
 
 	  If unsure, say N.
 
+config NFC_ST25DV
+	tristate "Support for ST25DV Chip"
+	depends on NFC_DIGITAL
+	---help---
+	  This module is a simple driver to drive the ST25DV eeprom. The ST25DV is 
+	  a EEPROM readable and writeable by i2c and also by wireless Near Field 
+	  Communication (NFC). Because the EEPROM can also be write by NFC, no cache 
+	  of the eeprom is done, to get the right data even if a write has been done 
+	  by NFC.
+
 source "drivers/nfc/fdp/Kconfig"
 source "drivers/nfc/pn544/Kconfig"
 source "drivers/nfc/pn533/Kconfig"
@@ -59,4 +69,5 @@ source "drivers/nfc/st-nci/Kconfig"
 source "drivers/nfc/nxp-nci/Kconfig"
 source "drivers/nfc/s3fwrn5/Kconfig"
 source "drivers/nfc/st95hf/Kconfig"
+
 endmenu
diff --git a/drivers/nfc/Makefile b/drivers/nfc/Makefile
index 5393ba59b17d..4c5fe7793356 100644
--- a/drivers/nfc/Makefile
+++ b/drivers/nfc/Makefile
@@ -17,3 +17,4 @@ obj-$(CONFIG_NFC_ST_NCI)	+= st-nci/
 obj-$(CONFIG_NFC_NXP_NCI)	+= nxp-nci/
 obj-$(CONFIG_NFC_S3FWRN5)	+= s3fwrn5/
 obj-$(CONFIG_NFC_ST95HF)	+= st95hf/
+obj-$(CONFIG_NFC_ST25DV)	+= st25dv.o
diff --git a/drivers/nfc/st25dv.c b/drivers/nfc/st25dv.c
new file mode 100644
index 000000000000..67a14d7044b3
--- /dev/null
+++ b/drivers/nfc/st25dv.c
@@ -0,0 +1,540 @@
+/*
+ * Copyright (C) 2018 Loc Boban <loic.boban@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+
+#define DYN_REG_SIZE		0x8
+#define SYS_MEM_SIZE		0x24
+#define USER_MEM_SIZE		0x200
+#define MAILBOX_MEM_SIZE        0x100
+#define SYS_ADDR		0x57
+#define USER_ADDR		0x53
+#define PWD_OFF			0x0900
+#define DYN_REG_OFF		0x2000
+#define MAILBOX_OFF		0x2008
+#define MAX_TRY			10
+
+#define PWD_REQ_SIZE		0x13
+#define PWD_SIZE		0x08
+#define CMD_PRESENT_PWD		0x09
+#define CMD_WRITE_PWD		0x07
+#define PWD_CMD_POS 		10
+#define PWD1_POS 		2
+#define PWD2_POS 		11
+
+#define MEM_04K                 512
+#define MEM_16K                 2000
+#define MEM_64K                 8000
+
+static const struct bin_attribute st25dv_p_pwd_attr;
+
+enum area_type{
+	USER_AREA = 0,
+	SYS_AREA = 1,
+	DYN_REG_AREA = 2,
+	MAILBOX_AREA = 3,
+};
+
+/*the st25dv eeprom have two areas, the user area, and the system 
+area to manage read/write protection for the NFC interface and I2C
+interface. To drive the system area a dummy i2c_client is used*/
+static int mem_config[4] = {MEM_04K, MEM_04K, MEM_16K, MEM_64K};
+static int area_off[4] = {0, 0, DYN_REG_OFF, MAILBOX_OFF};
+
+/*one struct is used for each area*/
+struct st25dv_data {
+	u8 *data;//area data
+	enum area_type type;
+	struct bin_attribute bin_attr;
+	struct i2c_client *client;
+        struct mutex *update_lock;//protect for concurrent updates
+	struct st25dv_data *next;
+};
+
+/* Addresses to scan */
+static const unsigned short normal_i2c[] = { USER_ADDR, SYS_ADDR, I2C_CLIENT_END };
+
+static ssize_t st25dv_read(struct file *filp, struct kobject *kobj,
+			   struct bin_attribute *bin_attr, char *buf, loff_t off, size_t count)
+{
+	int r_size, nack;
+	struct i2c_client *client = to_i2c_client(kobj_to_dev(kobj));
+	struct st25dv_data *data = i2c_get_clientdata(client);
+	u16 cur_off;
+
+	while(&data->bin_attr != bin_attr){
+		data = data->next;
+	}
+	off += area_off[data->type];
+	mutex_lock(data->update_lock);
+	for(cur_off = off; cur_off-off < count; cur_off++){
+		nack = 0;
+retry_:
+		if(nack > MAX_TRY){
+			mutex_unlock(data->update_lock);
+			return r_size;
+		}
+		r_size = i2c_smbus_write_byte_data(client, (cur_off >> 8) & 0x0ff, cur_off & 0x0ff);
+		if(r_size < 0){
+			nack++;
+			udelay(150);
+			goto retry_;
+		}
+		r_size = i2c_smbus_read_byte(client);
+		if(r_size < 0){
+			nack++;
+			udelay(150);
+			goto retry_;
+		}
+		data->data[cur_off] = r_size;
+	}
+	memcpy(buf, &data->data[off], count);
+	mutex_unlock(data->update_lock);
+	//printk(KERN_WARNING "st25dv: %d byte reads.\n",count);
+
+	return count;
+}
+
+static ssize_t st25dv_write_area(struct file *filp, struct kobject *kobj,
+			struct bin_attribute *bin_attr, char *buf, loff_t off, size_t count)
+{
+	int r_size;
+	struct i2c_client *client = to_i2c_client(kobj_to_dev(kobj));
+	struct st25dv_data *data = i2c_get_clientdata(client);
+	u16 cur_off, tmp;
+	u8 nack;
+
+	while(&data->bin_attr != bin_attr){
+		data = data->next;
+	}
+	off += area_off[data->type];
+	mutex_lock(data->update_lock);
+	memcpy(data->data + off, buf, count);
+	for(cur_off = off; cur_off-off < count; cur_off++){
+		nack = 0;
+		tmp = data->data[cur_off];
+		tmp = (tmp << 8) & 0xff00;
+		tmp |= cur_off & 0x00ff;
+retry_:
+		if(nack > MAX_TRY){
+			mutex_unlock(data->update_lock);
+			return r_size;
+		}
+		r_size = i2c_smbus_write_word_data(client, (cur_off >> 8) & 0x0ff, tmp );
+		if(r_size < 0){
+			nack++;
+			mdelay(1);
+			goto retry_;
+		}
+
+	}
+	mutex_unlock(data->update_lock);
+	//printk(KERN_WARNING "st25dv: %d byte writes.\n",count);
+
+	return count;
+}
+
+//I2C_SMBUS_BLOCK_MAX = 9 page writes
+//MAX tw = 9 * 5ms
+//write_block is faster than write single byte but not supported by some adapter 
+static ssize_t st25dv_write_block(struct file *filp, struct kobject *kobj,
+				  struct bin_attribute *bin_attr, char *buf, loff_t off, size_t count)
+{
+	int r_size, to_write, not_write;
+	struct i2c_client *client = to_i2c_client(kobj_to_dev(kobj));
+	struct st25dv_data *data = i2c_get_clientdata(client);
+	u16 cur_off, cur_buf_off;
+	u8 nack, tmp[I2C_SMBUS_BLOCK_MAX];
+
+	while(&data->bin_attr != bin_attr){
+		data = data->next;
+	}
+	off += area_off[data->type];
+	mutex_lock(data->update_lock);
+	memcpy(data->data + off, buf, count);
+	not_write = count;
+	cur_off = off;
+	cur_buf_off = 0;
+	while(not_write){
+		nack = 0;
+		to_write = not_write > I2C_SMBUS_BLOCK_MAX-2 ? I2C_SMBUS_BLOCK_MAX-2 : not_write;
+		not_write -= to_write;
+		tmp[1] = cur_off;
+		tmp[0] = cur_off >> 8;
+		memcpy(tmp + 2, buf + cur_buf_off, to_write);
+retry_:
+		if(nack > MAX_TRY){
+			mutex_unlock(data->update_lock);
+			return r_size;
+		}
+		r_size = i2c_master_send(client, tmp, to_write+2);
+		if(r_size < 0){
+			nack++;
+			mdelay(5);
+			goto retry_;
+		}
+		mdelay(20);
+		cur_off += to_write;
+		cur_buf_off += to_write;
+	}
+
+	mutex_unlock(data->update_lock);
+	//printk(KERN_WARNING "st25dv: %d byte writes.\n",count);
+
+	return count;
+}
+
+static ssize_t st25dv_send_pwd_req(struct file *filp, struct kobject *kobj,
+			   struct bin_attribute *bin_attr,
+				   char *buf, loff_t off, size_t count)
+{
+	u8 pwd_req[PWD_REQ_SIZE], cmd, *pwd_ptr1, *pwd_ptr2;
+	int r_size, off_tmp, nack;
+	struct i2c_client *client = to_i2c_client(kobj_to_dev(kobj));
+	struct st25dv_data *data = i2c_get_clientdata(client);
+
+	cmd = bin_attr == &st25dv_p_pwd_attr ? CMD_PRESENT_PWD : CMD_WRITE_PWD;
+	if(count != PWD_SIZE){
+		printk(KERN_WARNING "st25dv: send pwd cmd fail count=%d.\n", count);
+		return count;
+	}
+	nack = 0;
+	pwd_req[0] = 0x09;
+	pwd_req[1] = 0x00;
+	pwd_ptr1 = &pwd_req[PWD1_POS];
+	pwd_ptr2 = &pwd_req[PWD2_POS];
+	pwd_req[PWD_CMD_POS] = cmd;
+	for(off_tmp = PWD_SIZE-1; off_tmp >= 0; off_tmp--){
+		*pwd_ptr1 = buf[off_tmp];
+		*pwd_ptr2 = buf[off_tmp];
+		pwd_ptr1++;
+		pwd_ptr2++;
+	}
+	mutex_lock(data->update_lock);
+retry_:
+	if(nack > MAX_TRY){
+		mutex_unlock(data->update_lock);
+		return r_size;
+	}
+	r_size = i2c_master_send(client, pwd_req, PWD_REQ_SIZE);
+	if(r_size < 0){
+		nack++;
+		mdelay(5);
+		goto retry_;
+	}
+	mutex_unlock(data->update_lock);
+	//printk(KERN_WARNING "st25dv: send pwd cmd send.\n");
+
+	return count;
+}
+
+static struct bin_attribute st25dv_user_attr = {
+	.attr = {
+		.name = "st25dv_user",
+		.mode = S_IRUGO|S_IWUGO,
+	},
+	.size = USER_MEM_SIZE,
+	.read = st25dv_read,
+	.write = st25dv_write_block,
+};
+
+static const struct bin_attribute st25dv_sys_attr = {
+	.attr = {
+		.name = "st25dv_sys",
+		.mode = S_IRUGO|S_IWUSR,
+	},
+	.size = SYS_MEM_SIZE,
+	.read = st25dv_read,
+        .write = st25dv_write_block,
+};
+
+static const struct bin_attribute st25dv_dyn_reg_attr = {
+        .attr = {
+                .name = "st25dv_dyn_reg",
+                .mode = S_IRUGO|S_IWUSR,
+  },
+        .size = DYN_REG_SIZE,
+        .read = st25dv_read,
+        .write = st25dv_write_block,
+};
+
+static const struct bin_attribute st25dv_mailbox_attr = {
+        .attr = {
+                .name = "st25dv_mailbox",
+                .mode = S_IRUGO|S_IWUGO,
+  },
+        .size = MAILBOX_MEM_SIZE,
+        .read = st25dv_read,
+        .write = st25dv_write_block,
+};
+
+static const struct bin_attribute st25dv_w_pwd_attr = {
+	.attr = {
+		.name = "st25dv_write_pwd",
+		.mode = S_IWUSR,
+	},
+	.size = PWD_SIZE,
+	.write = st25dv_send_pwd_req,
+};
+
+static const struct bin_attribute st25dv_p_pwd_attr = {
+	.attr = {
+		.name = "st25dv_present_pwd",
+		.mode = S_IWUSR,
+	},
+	.size = PWD_SIZE,
+	.write = st25dv_send_pwd_req,
+};
+
+/* Return 0 if detection is successful, -ENODEV otherwise */
+static int st25dv_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	if (!(adapter->class & I2C_CLASS_SPD) && (client->addr != USER_ADDR)){
+		printk(KERN_WARNING "not st25dv eeprom.\n");
+		return -ENODEV;
+	}
+	if(!i2c_new_dummy(client->adapter, SYS_ADDR)){
+		printk(KERN_WARNING "not st25dv eeprom.\n");
+		return -ENODEV;
+	}
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_READ_WORD_DATA)
+	 && !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_READ_I2C_BLOCK)){
+		printk(KERN_WARNING "st25dv eeprom detect but no functionality.\n");
+		return -ENODEV;
+	}
+	printk(KERN_WARNING "st25dv eeprom detect.\n");
+	strlcpy(info->type, "st25dv", I2C_NAME_SIZE);
+
+	return 0;
+}
+
+static int st25dv_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int status;
+	struct mutex *st25dv_lock;
+	struct st25dv_data *data;
+	struct st25dv_data *sys_data;
+	struct st25dv_data *dyn_reg_data;
+	struct st25dv_data *mailbox_data;
+	struct i2c_client *client_sys_area;//i2c_client of the system area
+
+	/*dummy client for the system area at addr 0x57*/
+	client_sys_area = i2c_new_dummy(client->adapter, SYS_ADDR);
+	if(!client_sys_area){
+		printk(KERN_WARNING "st25dv sys eeprom not detected.\n");
+		return -ENODEV;
+	} 
+	data = devm_kzalloc(&client->dev, sizeof(struct st25dv_data), GFP_KERNEL);
+	if (!data)
+		goto err_mem;
+	data->data = kmalloc(sizeof(u8)*mem_config[id->driver_data], GFP_KERNEL);
+	if (!data->data)
+		goto err_mem7;
+	sys_data = devm_kzalloc(&client_sys_area->dev, sizeof(struct st25dv_data)
+				, GFP_KERNEL);
+	if (!sys_data)
+		goto err_mem6;
+	sys_data->data = kmalloc(sizeof(u8)*SYS_MEM_SIZE, GFP_KERNEL);
+	if (!sys_data->data)
+		goto err_mem5;
+	dyn_reg_data = kmalloc(sizeof(struct st25dv_data), GFP_KERNEL);
+	if(!dyn_reg_data)
+		goto err_mem4;
+	dyn_reg_data->data = kmalloc(sizeof(u8)*DYN_REG_SIZE, GFP_KERNEL);
+	if (!dyn_reg_data->data)
+		goto err_mem3;
+	mailbox_data = kmalloc(sizeof(struct st25dv_data), GFP_KERNEL);
+	if(!mailbox_data)
+		goto err_mem2;
+        mailbox_data->data = kmalloc(sizeof(u8)*MAILBOX_MEM_SIZE, GFP_KERNEL);
+	if (!mailbox_data->data)
+		goto err_mem1;
+
+	st25dv_lock = kmalloc(sizeof(struct mutex), GFP_KERNEL);
+	if (!st25dv_lock)
+	        goto err_mem0;    
+	mutex_init(st25dv_lock);
+	data->client =  client;
+	sys_data->client = client_sys_area;
+	mailbox_data->client = client;
+	dyn_reg_data->client = client;
+	memset(data->data, 0xff, mem_config[id->driver_data]);
+	memset(sys_data->data, 0xff, SYS_MEM_SIZE);
+	memset(dyn_reg_data->data, 0xff, DYN_REG_SIZE);
+	memset(mailbox_data->data, 0xff, MAILBOX_MEM_SIZE);
+
+	/*set circular linked list and shared mutex*/
+	data->next = dyn_reg_data;
+	data->update_lock = st25dv_lock;
+	dyn_reg_data->next = mailbox_data;
+	dyn_reg_data->update_lock = st25dv_lock;
+	mailbox_data->next = sys_data;
+        mailbox_data->update_lock = st25dv_lock;
+	sys_data->next = data;
+	sys_data->update_lock = st25dv_lock;
+
+	memcpy(&mailbox_data->bin_attr, &st25dv_mailbox_attr, sizeof(struct bin_attribute));
+	memcpy(&dyn_reg_data->bin_attr, &st25dv_dyn_reg_attr, sizeof(struct bin_attribute));
+	memcpy(&sys_data->bin_attr, &st25dv_sys_attr, sizeof(struct bin_attribute));
+	memcpy(&data->bin_attr, &st25dv_user_attr, sizeof(struct bin_attribute));
+	data->bin_attr.size = mem_config[id->driver_data];
+	data->type = USER_AREA;
+	dyn_reg_data->type = DYN_REG_AREA;
+	sys_data->type = SYS_AREA;
+	mailbox_data->type = MAILBOX_AREA;
+	i2c_set_clientdata(client, data);
+	i2c_set_clientdata(client_sys_area, sys_data);
+	
+	/* create tree sysfs eeprom files to for pwd, user area,
+	 system area and dynamic registers */
+	status = sysfs_create_bin_file(&client->dev.kobj, &data->bin_attr);
+	if(status < 0)
+		goto err_sysfs;
+	status = sysfs_create_bin_file(&client_sys_area->dev.kobj, &sys_data->bin_attr);
+	if(status < 0)
+		goto err_sysfs4;
+	status = sysfs_create_bin_file(&client->dev.kobj, &dyn_reg_data->bin_attr);
+	if(status < 0)
+		goto err_sysfs3;
+	status = sysfs_create_bin_file(&client_sys_area->dev.kobj, &st25dv_w_pwd_attr);
+	if(status < 0)
+		goto err_sysfs2;
+	status = sysfs_create_bin_file(&client_sys_area->dev.kobj, &st25dv_p_pwd_attr);
+	if(status < 0)
+		goto err_sysfs1;
+	status = sysfs_create_bin_file(&client->dev.kobj, &mailbox_data->bin_attr);
+	if(status < 0)
+		goto err_sysfs0;
+	printk(KERN_WARNING "st25dv eeprom create bin file.\n");
+	return status;
+err_sysfs0:
+	sysfs_remove_bin_file(&client_sys_area->dev.kobj, &st25dv_p_pwd_attr);
+err_sysfs1:
+	sysfs_remove_bin_file(&client_sys_area->dev.kobj, &st25dv_w_pwd_attr);
+err_sysfs2:
+	sysfs_remove_bin_file(&client->dev.kobj, &dyn_reg_data->bin_attr);
+err_sysfs3:
+	sysfs_remove_bin_file(&client_sys_area->dev.kobj, &sys_data->bin_attr);
+err_sysfs4:
+	sysfs_remove_bin_file(&client->dev.kobj, &data->bin_attr);
+err_sysfs:
+	printk(KERN_WARNING "fail to create bin file.\n");
+err_mem0:
+	kfree(mailbox_data->data);
+err_mem1:
+	kfree(mailbox_data);
+err_mem2:
+	kfree(dyn_reg_data->data);
+err_mem3:
+	kfree(dyn_reg_data);
+err_mem4:
+	kfree(sys_data->data);
+err_mem5:
+	devm_kfree(&client_sys_area->dev, sys_data);
+	i2c_unregister_device(client_sys_area);
+err_mem6:
+	kfree(data->data);
+err_mem7:
+	devm_kfree(&client->dev, data);
+err_mem:
+	printk(KERN_WARNING "not enougth memory.\n");
+	return -ENOMEM;
+}
+
+static int st25dv_remove(struct i2c_client *client)
+{
+	struct st25dv_data *data = i2c_get_clientdata(client);
+	struct st25dv_data *tmp_data2, *tmp_data;
+	struct i2c_client *client_sys_area;
+
+	/*get system area client*/
+	tmp_data = data;
+	while(tmp_data->type != SYS_AREA)
+		 tmp_data = tmp_data->next;	
+	client_sys_area = tmp_data->client;
+	/*remove pwd sysfs files*/
+	sysfs_remove_bin_file(&client_sys_area->dev.kobj, &st25dv_p_pwd_attr);
+	sysfs_remove_bin_file(&client_sys_area->dev.kobj, &st25dv_w_pwd_attr);
+	/*free all st25dv data allocations*/
+	tmp_data = data->next;
+	while(tmp_data != data){
+		/*remove areas sysfs files*/
+		sysfs_remove_bin_file(&tmp_data->client->dev.kobj, &tmp_data->bin_attr);
+		tmp_data2 = tmp_data;
+		kfree(tmp_data->data);
+		tmp_data = tmp_data->next;
+		/*sys_area data will be free by i2c_unregister_device*/
+		if(tmp_data2->type != SYS_AREA)
+			kfree(tmp_data2);
+	}
+	/*free st25dv user mem data*/
+	sysfs_remove_bin_file(&data->client->dev.kobj, &tmp_data->bin_attr);
+	kfree(data->data);
+	kfree(data->update_lock);
+	/*unregister dummy device*/
+	i2c_unregister_device(client_sys_area);
+
+	return 0;
+}
+
+static const struct i2c_device_id st25dv_id[] = {
+	{ "st25dv", 0 },
+	{ "st25dv04k", 1 },
+	{ "st25dv16k", 2 },
+	{ "st25dv64k", 3 },
+	{ }
+};
+
+static struct i2c_driver st25dv_driver = {
+	.driver = {
+		.name	= "st25dv",
+	},
+	.probe		= st25dv_probe,
+	.remove		= st25dv_remove,
+	.id_table	= st25dv_id,
+
+	.class		= I2C_CLASS_DDC | I2C_CLASS_SPD,
+	.detect		= st25dv_detect,
+	.address_list	= normal_i2c,
+};
+
+static int __init st25dv_i2c_init_driver(void)
+{
+	printk(KERN_WARNING "init st25dv eeprom driver.\n");
+	return i2c_add_driver(&st25dv_driver);
+}
+
+static void __exit st25dv_i2c_exit_driver(void)
+{
+	printk(KERN_WARNING "remove st25dv eeprom driver.\n");
+	i2c_del_driver(&st25dv_driver);
+}
+
+module_init(st25dv_i2c_init_driver);
+module_exit(st25dv_i2c_exit_driver);
+
+MODULE_INFO(intree, "y");
+MODULE_AUTHOR("Loc Boban <loic.boban@gmail.com>");
+MODULE_DESCRIPTION("nfc/i2c eeprom st25dv driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/nvmem/core.c b/drivers/nvmem/core.c
index cde1d77845fe..fcedc7da4597 100644
--- a/drivers/nvmem/core.c
+++ b/drivers/nvmem/core.c
@@ -313,6 +313,8 @@ static int nvmem_add_cells_from_of(struct nvmem_device *nvmem)
 	parent = dev->of_node;
 
 	for_each_child_of_node(parent, child) {
+		if (!strchr(kbasename(child->full_name), '@'))
+			continue;
 		addr = of_get_property(child, "reg", &len);
 		if (!addr)
 			continue;
diff --git a/include/media/i2c/mt9p031.h b/include/media/i2c/mt9p031.h
index 7c29c53aa988..f933cd0be8e5 100644
--- a/include/media/i2c/mt9p031.h
+++ b/include/media/i2c/mt9p031.h
@@ -10,6 +10,7 @@ struct v4l2_subdev;
  * @target_freq: Pixel clock frequency
  */
 struct mt9p031_platform_data {
+	unsigned int pixclk_pol:1;
 	int ext_freq;
 	int target_freq;
 };
